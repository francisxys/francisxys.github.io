<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="_1iFxvEkIImQlyvWe4Y4gLh85rLCe9HPYV56NcoolIE">








  <meta name="baidu-site-verification" content="RZoFTJvjGp">













<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="前言Nginx作用Nginx 是一个高性能的 Web 和反向代理服务器, 它具有有很多非常优越的特性:作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。能够支持高达 50,000 个并发连接数的响应，感谢 Nginx 为我们选择了 epoll and kqueue 作为开发模型.作为负载均衡服">
<meta name="keywords" content="Nginx">
<meta property="og:type" content="article">
<meta property="og:title" content="Nginx文档">
<meta property="og:url" content="http://www.cnops.com/posts/8dddf073.html">
<meta property="og:site_name" content="Francis&#39;Blog">
<meta property="og:description" content="前言Nginx作用Nginx 是一个高性能的 Web 和反向代理服务器, 它具有有很多非常优越的特性:作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。能够支持高达 50,000 个并发连接数的响应，感谢 Nginx 为我们选择了 epoll and kqueue 作为开发模型.作为负载均衡服">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://francisblogstatic.oss-cn-shanghai.aliyuncs.com/images/20190226001.png">
<meta property="og:image" content="https://francisblogstatic.oss-cn-shanghai.aliyuncs.com/images/20190226002.png">
<meta property="og:updated_time" content="2019-05-13T05:49:04.050Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nginx文档">
<meta name="twitter:description" content="前言Nginx作用Nginx 是一个高性能的 Web 和反向代理服务器, 它具有有很多非常优越的特性:作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。能够支持高达 50,000 个并发连接数的响应，感谢 Nginx 为我们选择了 epoll and kqueue 作为开发模型.作为负载均衡服">
<meta name="twitter:image" content="https://francisblogstatic.oss-cn-shanghai.aliyuncs.com/images/20190226001.png">






  <link rel="canonical" href="http://www.cnops.com/posts/8dddf073.html">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Nginx文档 | Francis'Blog</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Francis'Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Francis'Blog</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.cnops.com/posts/8dddf073.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Francis">
      <meta itemprop="description" content="云在青天水在瓶">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Francis'Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Nginx文档
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-26 10:20:15" itemprop="dateCreated datePublished" datetime="2019-02-26T10:20:15+08:00">2019-02-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-13 13:49:04" itemprop="dateModified" datetime="2019-05-13T13:49:04+08:00">2019-05-13</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Service/" itemprop="url" rel="index"><span itemprop="name">Service</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Service/Nginx/" itemprop="url" rel="index"><span itemprop="name">Nginx</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">97k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:28</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="Nginx作用"><a href="#Nginx作用" class="headerlink" title="Nginx作用"></a>Nginx作用</h3><p>Nginx 是一个高性能的 Web 和反向代理服务器, 它具有有很多非常优越的特性:<br>作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。能够支持高达 50,000 个并发连接数的响应，感谢 Nginx 为我们选择了 epoll and kqueue 作为开发模型.<br>作为负载均衡服务器：Nginx 既可以在内部直接支持 Rails 和 PHP，也可以支持作为 HTTP代理服务器 对外进行服务。Nginx 用 C 编写, 不论是系统资源开销还是 CPU 使用效率都比 Perlbal 要好的多。<br>作为邮件代理服务器: Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器），Last.fm 描述了成功并且美妙的使用经验。<br>Nginx 安装非常的简单，配置文件 非常简洁（还能够支持perl语法），Bugs非常少的服务器: Nginx 启动特别容易，并且几乎可以做到7x24不间断运行，即使运行数个月也不需要重新启动。你还能够在 不间断服务的情况下进行软件版本的升级。</p>
<h3 id="Nginx版本选择"><a href="#Nginx版本选择" class="headerlink" title="Nginx版本选择"></a>Nginx版本选择</h3><p>Nginx官方网站为： nginx.org<br>Nginx的版本有：</p>
<pre><code>Mainline version：Mainline 是 Nginx 目前主力在做的版本，可以说是开发版。
Stable version：最新稳定版，生产环境上建议使用的版本。
Legacy versions：遗留的老版本的稳定版。
</code></pre><p>一般就选最新版本，Stable version：最新稳定版。</p>
<h2 id="Nginx安装、升级、卸载"><a href="#Nginx安装、升级、卸载" class="headerlink" title="Nginx安装、升级、卸载"></a>Nginx安装、升级、卸载</h2><h3 id="windows-server环境安装"><a href="#windows-server环境安装" class="headerlink" title="windows server环境安装"></a>windows server环境安装</h3><h4 id="下载解压后"><a href="#下载解压后" class="headerlink" title="下载解压后"></a>下载解压后</h4><p><img src="https://francisblogstatic.oss-cn-shanghai.aliyuncs.com/images/20190226001.png" alt="Alt text" title="Francis&#39;Blog"></p>
<h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>Nginx的配置文件在./conf/nginx.conf<br><img src="https://francisblogstatic.oss-cn-shanghai.aliyuncs.com/images/20190226002.png" alt="Alt text" title="Francis&#39;Blog"><br>具体的相关配置请查看后续内容</p>
<h4 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h4><p>注意不要直接双击nginx.exe，这样会导致修改配置后重启、停止nginx无效，需要手动关闭任务管理器内的所有nginx进程<br>在nginx.exe目录，打开命令行工具，用命令 启动/关闭/重启nginx<br>启动nginx：<br>nginx -s reload  ：修改配置后重新加载生效<br>nginx -s reopen  ：重新打开日志文件<br>nginx -t -c /path/to/nginx.conf 测试nginx配置文件是否正确<br>关闭nginx：<br>nginx -s stop  :快速停止nginx<br>nginx -s quit  ：完整有序的停止nginx</p>
<h3 id="linux-server安装Nginx"><a href="#linux-server安装Nginx" class="headerlink" title="linux server安装Nginx"></a>linux server安装Nginx</h3><p>Linux server环境以centos7作为环境示例，文档着重讲述linux server环境下Nginx的使用配置等操作。</p>
<h4 id="yum安装方式"><a href="#yum安装方式" class="headerlink" title="yum安装方式"></a>yum安装方式</h4><p>CentOS 7 中的 yum 没法直接使用 yum install nginx 这个指令去安装nginx，因为nginx这个服务不是yum库中自带的。首先添加yum源：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure></p>
<p>可以通过yum search nginx查看yum源是否安装成功，如果安装成功，则可以使用以下命令安装nginx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure></p>
<p>启动Nginx并设置开机自动运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx.service</span><br><span class="line">systemctl <span class="built_in">enable</span> nginx.service</span><br></pre></td></tr></table></figure></p>
<h4 id="编译安装方式"><a href="#编译安装方式" class="headerlink" title="编译安装方式"></a>编译安装方式</h4><p>安装编译环境、gcc<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ automake autoconf libtool make</span><br><span class="line">yum install gcc gcc-c++</span><br></pre></td></tr></table></figure></p>
<p>一般我们都需要先装pcre, zlib，前者为了重写rewrite，后者为了gzip压缩。从<a href="ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/" target="_blank" rel="noopener">ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/</a> 下载最新的 PCRE 源码包，使用下面命令下载编译和安装 PCRE 包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/backup</span><br><span class="line">wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.42.tar.gz</span><br><span class="line">tar -zxvf pcre-8.42.tar.gz</span><br><span class="line"><span class="built_in">cd</span> pcre-8.42</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p>
<p>从<a href="http://zlib.net下载最新的" target="_blank" rel="noopener">http://zlib.net下载最新的</a> zlib 源码包，使用下面命令下载编译和安装 zlib包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/backup</span><br><span class="line">wget http://zlib.net/zlib-1.2.11.tar.gz </span><br><span class="line">tar -zxvf zlib-1.2.11.tar.gz</span><br><span class="line"><span class="built_in">cd</span> zlib-1.2.11</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p>
<p>安装openssl<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/backup</span><br><span class="line">wget https://www.openssl.org/<span class="built_in">source</span>/openssl-1.1.0h.tar.gz</span><br><span class="line">tar -zxvf openssl-1.1.0h.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>安装Nginx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/backup</span><br><span class="line">wget http://nginx.org/download/nginx-1.14.0.tar.gz</span><br><span class="line">tar -zxvf nginx-1.14.0.tar.gz </span><br><span class="line"><span class="built_in">cd</span> nginx-1.14.0</span><br><span class="line">./configure --prefix=/data/nginx/ --with-http_v2_module --with-http_ssl_module --with-http_sub_module --with-http_stub_status_module --with-http_gzip_static_module --without-http-cache --with-http_realip_module --with-pcre=/data/backup/pcre-8.42 --with-zlib=/data/backup/zlib-1.2.11 --with-openssl=/data/backup/openssl-1.1.0h</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p>
<p>创建Nginx软连接到环境变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /data/nginx/sbin/* /usr/sbin/</span><br></pre></td></tr></table></figure></p>
<p>至此Nginx的安装已经结束。</p>
<h3 id="Nginx升级、添加模块"><a href="#Nginx升级、添加模块" class="headerlink" title="Nginx升级、添加模块"></a>Nginx升级、添加模块</h3><p>如果要对当前的Nginx服务器进行版本升级，应用新模块，最简单的办法是停止当前Nginx服务，然后开启新的Nginx服务，但这样就会导致在一段时间内，用户无法访问服务器。为了解决这个问题，Nginx服务器提供平滑升级的功能。<br>平滑升级的过程是这样的，Nginx服务接收到USR2信号后首先将旧的nginx.pid文件(如果在配置文件中更改过这个文件的名字，也是相同的过程)添加.oldbin，变为nginx.pid.oldbin文件；然后执行新版本Nginx服务器的二进制文件启动服务。如果新的服务启动成功，系统中将由新旧两个Nginx服务公用提供Web服务。如果新的服务启动成功，系统中将有新旧两个Nginx服务共同提供Web服务。之后，需要向旧的Nginx服务进程发送WINCH信号，使旧的Nginx服务平滑停止，并删除nginx.pid.oldbin文件。在发送WINCH信号之前，可以随时停止新的Nginx服务。<br>注意：<br>为了实现Nginx服务器的平滑升级，新的服务器安装路径应该和旧的保持一致。因此建议用户在安装新服务器之前先备份旧服务器。<br>当前Nginx版本为1.12.2，官网提供最新版本为1.13.10（非稳定版本），本次升级到1.13.10。<br>和安装一样，首先下载解压，但是不要make install，编译参数中可以添加新的模块，以达到添加模块的目的，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/backup</span><br><span class="line">wget http://nginx.org/download/nginx-1.13.10.tar.gz</span><br><span class="line">tar -zxvf nginx-1.13.10.tar.gz </span><br><span class="line"><span class="built_in">cd</span> nginx-1.13.10</span><br><span class="line">./configure --prefix=/data/nginx/ --with-http_v2_module --with-http_ssl_module --with-http_sub_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre=/data/backup/pcre-8.42 --with-zlib=/data/backup/zlib-1.2.11 --with-openssl=/data/backup/openssl-1.1.0h</span><br><span class="line">make</span><br></pre></td></tr></table></figure></p>
<p>此时会在当前目录的objs文件夹内生成新版本的Nginx二进制文件。<br>平滑升级，先移走现有的Nginx二进制文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /data/nginx/sbin/nginx /data/nginx/sbin/nginx.old</span><br></pre></td></tr></table></figure></p>
<p>拷贝新生成的二进制文件到指定目录。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp objs/nginx /data/nginx/sbin</span><br></pre></td></tr></table></figure></p>
<p>执行升级<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make upgrade</span><br></pre></td></tr></table></figure></p>
<p>完成后再查看Nginx版本以及编译的参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx -V</span></span><br><span class="line">nginx version: nginx/1.13.10</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC) </span><br><span class="line">built with OpenSSL 1.1.0h  27 Mar 2018</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/data/nginx/ --with-http_v2_module --with-http_ssl_module --with-http_sub_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre=/data/backup/pcre-8.42 --with-zlib=/data/backup/zlib-1.2.11 --with-openssl=/data/backup/openssl-1.1.0h</span><br></pre></td></tr></table></figure></p>
<p>可以看到Nginx已升级完成，且模块也编译成功。</p>
<h3 id="Nginx卸载"><a href="#Nginx卸载" class="headerlink" title="Nginx卸载"></a>Nginx卸载</h3><p>Nginx在windows server比较容易删除，直接删除文件即可。Nginx在linux server上卸载的话，如果编译时的路径如果指定了–prefix /xxx/nginx 直接rm -rf /xxx/nginx即可。如果没指定路径，那就到源码路径执行make uninstall。如果源码已经删除，安装时也没有指定路径，则需要到/usr/bin /etc /usr/sbin /usr/lib找到相关文件手动删除。</p>
<h2 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#检查配置文件</span></span><br><span class="line">nginx -t</span><br><span class="line"><span class="comment">#指定其他配置文件启动Nginx</span></span><br><span class="line">nginx -c /data/nginx/conf/nginx.conf.default</span><br><span class="line"><span class="comment">#启动Nginx</span></span><br><span class="line">nginx</span><br><span class="line"><span class="comment">#停止Nginx</span></span><br><span class="line">nginx -s stop</span><br><span class="line"><span class="comment">#重启Nginx</span></span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<p>参数解释</p>
<pre><code>-s stop 快速停止nginx  
-s quit 平滑停止nginx  
-s reopen 重新打开日志文件  
-s reload 平滑重载所有配置
</code></pre><h2 id="Nginx模块介绍"><a href="#Nginx模块介绍" class="headerlink" title="Nginx模块介绍"></a>Nginx模块介绍</h2><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><h4 id="主模块"><a href="#主模块" class="headerlink" title="主模块"></a>主模块</h4><p>包含一些Nginx的基本控制功能<br><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">daemon</span><br><span class="line">语法：daemon on | off</span><br><span class="line">默认值：on</span><br><span class="line">daemon off;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">env</span><br><span class="line">语法：env VAR|VAR=VALUE</span><br><span class="line">默认值：TZ</span><br><span class="line">使用字段：main</span><br><span class="line">这个命令允许其限定一些环境变量的值，在以下的情况下会创建或修改变量的值：</span><br><span class="line">在不停机情况下升级、增加或删除一些模块时继承的变量</span><br><span class="line">使用嵌入式perl模块</span><br><span class="line">使用工作中的进程，必须记住，某些类似系统库的行为管理仅在变量初始化时频繁地使用库文件，即仍然可以用之前给定的命令设置。</span><br><span class="line">如果没有明确的定义TZ的值,默认情况下它总是继承的，并且内置的Perl模块总是可以使用TZ的值。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">debug_points</span><br><span class="line">语法：debug_points [stop | abort] </span><br><span class="line">默认值：none（无）</span><br><span class="line">debug_points stop;</span><br><span class="line">在Nginx内部有很多断言，如果debug_points的值设为stop时，那么触发断言时将停止Nginx并附加调试器。如果debug_point的值设为abort,那么触发断言时将创建内核文件。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">error_log</span><br><span class="line">语法：error_log file [ debug | info | notice | warn | error | crit ] </span><br><span class="line">默认值：<span class="variable">$&#123;prefix&#125;</span>/logs/error.log</span><br><span class="line">指定Nginx服务（与FastCGI）错误日志文件位置。</span><br><span class="line">每个字段的错误日志等级默认值：</span><br><span class="line">1、main字段 - error</span><br><span class="line">2、HTTP字段 - crit</span><br><span class="line">3、server字段 - crit</span><br><span class="line">Nginx支持为每个虚拟主机设置不同的错误日志文件，这一点要好于lighttpd，如果你在编译安装Nginx时加入了--with-debug参数，你可以使用以下配置：</span><br><span class="line">error_log LOGFILE [debug_core | debug_alloc | debug_mutex | debug_event | debug_http | debug_imap];</span><br><span class="line">注意error_log off并不能关闭日志记录功能，而会将日志文件写入一个文件名为off的文件中，如果你想关闭错误日志记录功能，应使用以下配置：</span><br><span class="line">error_log /dev/null crit;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">log_not_found</span><br><span class="line">语法：log_not_found on | off </span><br><span class="line">默认值：on </span><br><span class="line">使用字段：location </span><br><span class="line">这个参数指定了是否记录客户端的请求出现404错误的日志，通常用于不存在的robots.txt和favicon.ico文件，例如：</span><br><span class="line">location = /robots.txt &#123;</span><br><span class="line">  log_not_found  off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">include</span><br><span class="line">语法：include file | * </span><br><span class="line">默认值：none </span><br><span class="line">你可以包含一些其他的配置文件来完成你想要的功能。</span><br><span class="line">0.4.4版本以后，include指令已经能够支持文件通配符：</span><br><span class="line">include vhosts/*.conf;</span><br><span class="line">注意：直到0.6.7版本，这个参数包含的文件相对路径随你在编译时指定的--prefix=PATH目录而决定，默认是/usr/<span class="built_in">local</span>/nginx，如果你不想指定这个目录下的文件，请写绝对路径。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lock_file</span><br><span class="line">语法：lock_file file </span><br><span class="line">默认值：编译时指定 </span><br><span class="line">lock_file  /var/<span class="built_in">log</span>/lock_file;</span><br><span class="line">Nginx使用连接互斥锁进行顺序的accept()系统调用，如果Nginx在i386,amd64,sparc64,与ppc64环境下使用gcc,Intel C++,或SunPro C++进行编译，Nginx将采用异步互斥进行访问控制，在其他情况下锁文件会被使用。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">master_process</span><br><span class="line">语法：master_process on | off </span><br><span class="line">默认值：on </span><br><span class="line">master_process  off;</span><br><span class="line">生产环境中不要使用<span class="string">"daemon"</span>和<span class="string">"master_process"</span>指令，这些选项仅用于开发调试。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pid</span><br><span class="line">语法：pid file </span><br><span class="line">默认值：编译时指定 </span><br><span class="line">pid /var/<span class="built_in">log</span>/nginx.pid;</span><br><span class="line">指定pid文件，可以使用<span class="built_in">kill</span>命令来发送相关信号，例如你如果想重新读取配置文件，则可以使用：<span class="built_in">kill</span> -HUP `cat /var/<span class="built_in">log</span>/nginx.pid`</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ssl_engine</span><br><span class="line">语法：ssl_engine engine </span><br><span class="line">默认值：依赖于系统环境 </span><br><span class="line">这里可以指定你想使用的OpenSSL引擎，你可以使用这个命令找出哪个是可用的：openssl engine -t</span><br><span class="line">$ openssl engine -t</span><br><span class="line">(cryptodev) BSD cryptodev engine</span><br><span class="line">  [ 可用 ] </span><br><span class="line">(dynamic) Dynamic engine loading support</span><br><span class="line">  [ 不可用 ]</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">timer_resolution</span><br><span class="line">语法：timer_resolution t </span><br><span class="line">默认值：none </span><br><span class="line">timer_resolution  100ms;</span><br><span class="line">这个参数允许缩短gettimeofday()系统调用的时间，默认情况下gettimeofday()在下列都调用完成后才会被调用：kevent(), epoll, /dev/poll, select(), poll()。</span><br><span class="line">如果你需要一个比较准确的时间来记录<span class="variable">$upstream_response_time</span>或者<span class="variable">$msec</span>变量，你可能会用到timer_resolution</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try_files</span><br><span class="line">语法：try_files path1 [ path2] uri </span><br><span class="line">默认值：none</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user</span><br><span class="line">语法：user user [group] </span><br><span class="line">默认值：nobody nobody </span><br><span class="line">如果主进程以root运行，Nginx将会调用setuid()/setgid()来设置用户/组，如果没有指定组，那么将使用与用户名相同的组，默认情况下会使用nobody用户与nobody组（或者nogroup），或者在编译时指定的--user=USER和--group=GROUP的值。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">worker_cpu_affinity</span><br><span class="line">语法：worker_cpu_affinity cpumask [cpumask...] </span><br><span class="line">默认值：none </span><br><span class="line">仅支持linux系统。</span><br><span class="line">这个参数允许将工作进程指定到cpu，它调用sched_setaffinity()函数</span><br><span class="line">worker_processes     4;</span><br><span class="line">worker_cpu_affinity 0001 0010 0100 1000;</span><br><span class="line">指定每个进程到一个CPU：</span><br><span class="line">worker_processes     2;</span><br><span class="line">worker_cpu_affinity 0101 1010;</span><br><span class="line">指定第一个进程到CPU0/CPU2，指定第二个进程到CPU1/CPU3，对于HTT处理器来说是一个不错的选择。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">worker_priority</span><br><span class="line">语法：worker_priority [-] number </span><br><span class="line">默认值：on </span><br><span class="line">这个选项可以用来设置所有工作进程的优先级（即linux系统中的nice），它调用setpriority()。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">worker_processes</span><br><span class="line">语法：worker_processes number </span><br><span class="line">默认值：1 </span><br><span class="line">worker_processes 5;</span><br><span class="line">由于以下几点原因，Nginx可能需要运行不止一个进程</span><br><span class="line">1、使用了SMP（对称多处理技术）。</span><br><span class="line">2、当服务器在磁盘I/O出现瓶颈时为了减少响应时间。</span><br><span class="line">3、当使用select()/poll()限制了每个进程的最大连接数时。</span><br><span class="line">max_clients = worker_processes * worker_connections</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">worker_rlimit_core</span><br><span class="line">语法：worker_rlimit_core size </span><br><span class="line">默认值： </span><br><span class="line">允许的每个进程核心文件最大值。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">worker_rlimit_nofile</span><br><span class="line">语法：worker_rlimit_nofile <span class="built_in">limit</span> </span><br><span class="line">默认值： </span><br><span class="line">进程能够打开的最多文件描述符数</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">worker_rlimit_sigpending</span><br><span class="line">语法：worker_rlimit_sigpending <span class="built_in">limit</span> </span><br><span class="line">默认值： </span><br><span class="line">linux内核2.6.8以后，限制调用的进程中真实用户队列可能使用的信号数量。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">working_directory</span><br><span class="line">语法：working_directory path </span><br><span class="line">默认值：--prefix </span><br><span class="line">程序的工作目录，一般只用来指定核心文件位置，Nginx仅使用绝对路径，所有在配置文件中的相对路径会转移到--prefix==PATH</span><br></pre></td></tr></table></figure>
<p><strong>变量</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$pid</span></span><br><span class="line">进程ID号</span><br><span class="line"><span class="variable">$realpath_root</span></span><br></pre></td></tr></table></figure></p>
<h4 id="事件模块"><a href="#事件模块" class="headerlink" title="事件模块"></a>事件模块</h4><p>控制Nginx处理连接的方式<br><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">accept_mutex</span><br><span class="line">语法：accept_mutex [ on | off ] </span><br><span class="line">默认值：on </span><br><span class="line">Nginx使用连接互斥锁进行顺序的accept()系统调用</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">accept_mutex_delay</span><br><span class="line">语法：accept_mutex_delay Nms; </span><br><span class="line">默认值：500ms</span><br><span class="line">如果一个进程没有互斥锁，它将至少在这个值的时间后被回收，默认是500ms</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">debug_connection</span><br><span class="line">语法：debug_connection [ip | CIDR] </span><br><span class="line">默认值：none</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">devpoll_changes</span><br><span class="line">devpoll_events </span><br><span class="line">kqueue_changes</span><br><span class="line">kqueue_events </span><br><span class="line">epoll_events</span><br><span class="line">语法：devpoll_changes </span><br><span class="line">默认值：</span><br><span class="line">这些参数指定了按照规定方式传递到或者来自内核的事件数，默认devpoll的值为32，其余为512。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multi_accept</span><br><span class="line">语法：multi_accept [ on | off ] </span><br><span class="line">默认值：off </span><br><span class="line">multi_accept在Nginx接到一个新连接通知后调用accept()来接受尽量多的连接</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rtsig_signo</span><br><span class="line">语法：rtsig_signo </span><br><span class="line">默认值：</span><br><span class="line">Nginx在rtsig模式启用后使用两个信号，该指令指定第一个信号编号，第二个信号编号为第一个加1</span><br><span class="line">默认rtsig_signo的值为SIGRTMIN+10 (40)</span><br></pre></td></tr></table></figure>
<h3 id="标准HTTP模块"><a href="#标准HTTP模块" class="headerlink" title="标准HTTP模块"></a>标准HTTP模块</h3><h4 id="HTTP核心模块"><a href="#HTTP核心模块" class="headerlink" title="HTTP核心模块"></a>HTTP核心模块</h4><p>Nginx处理HTTP的核心功能模块<br><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span></span><br><span class="line">语法：<span class="built_in">alias</span> file-path|directory-path; </span><br><span class="line">默认值：no</span><br><span class="line">使用字段：location</span><br></pre></td></tr></table></figure></p>
<p>这个指令指定一个路径使用某个某个，注意它可能类似于root，但是document root没有改变，请求只是使用了别名目录的文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location  /i/ &#123;</span><br><span class="line">  <span class="built_in">alias</span>  /spool/w3/images/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上个例子中，请求”/i/top.gif”将返回这个文件: “/spool/w3/images/top.gif”。<br>Alias同样可以用于带正则表达式的location，如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ ^/download/(.*)$ &#123;</span><br><span class="line">  <span class="built_in">alias</span> /home/website/files/<span class="variable">$1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请求”/download/book.pdf”将返回”/home/website/files/book.pdf”。<br>同样，也可以在别名目录字段中使用变量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client_body_in_file_only</span><br><span class="line">语法：client_body_in_file_only on|off </span><br><span class="line">默认值：off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>这个指令始终存储一个连接请求实体到一个文件即使它只有0字节。<br>注意：如果这个指令打开，那么一个连接请求完成后，所存储的文件并不会删除。<br>这个指令可以用于debug调试和嵌入式Perl模块中的$r-&gt;request_body_file。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client_body_in_single_buffer</span><br><span class="line">语法：client_body_in_single_buffer </span><br><span class="line">默认值：off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client_body_buffer_size</span><br><span class="line">语法：client_body_buffer_size the_size </span><br><span class="line">默认值：8k/16k </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure>
<p>这个指令可以指定连接请求实体的缓冲区大小。<br>如果连接请求超过缓存区指定的值，那么这些请求实体的整体或部分将尝试写入一个临时文件。<br>默认值为两个内存分页大小值，根据平台的不同，可能是8k或16k。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client_body_temp_path</span><br><span class="line">语法：client_body_temp_path dir-path [ level1 [ level2 [ level3 ] </span><br><span class="line">默认值：client_body_temp </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>指令指定连接请求实体试图写入的临时文件路径。<br>可以指定三级目录结构，如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client_body_temp_path  /spool/nginx/client_temp 1 2;</span><br></pre></td></tr></table></figure></p>
<p>那么它的目录结构可能是这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/spool/nginx/client_temp/7/45/00000123457</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">client_body_timeout</span><br><span class="line">语法：client_body_timeout time</span><br><span class="line">默认值：60 </span><br><span class="line">使用字段：http, server, location </span><br><span class="line">指令指定读取请求实体的超时时间。</span><br><span class="line">这里的超时是指一个请求实体没有进入读取步骤，如果连接超过这个时间而客户端没有任何响应，Nginx将返回一个<span class="string">"Request time out"</span> (408)错误</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">client_header_buffer_size</span><br><span class="line">语法：client_header_buffer_size size </span><br><span class="line">默认值：1k </span><br><span class="line">使用字段：http, server </span><br><span class="line">指令指定客户端请求头部的缓冲区大小</span><br><span class="line">绝大多数情况下一个请求头不会大于1k</span><br><span class="line">不过如果有来自于wap客户端的较大的cookie它可能会大于1k，Nginx将分配给它一个更大的缓冲区，这个值可以在large_client_header_buffers里面设置。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">client_header_timeout</span><br><span class="line">语法：client_header_timeout time </span><br><span class="line">默认值：60 </span><br><span class="line">使用字段：http, server </span><br><span class="line">指令指定读取客户端请求头标题的超时时间。</span><br><span class="line">这里的超时是指一个请求头没有进入读取步骤，如果连接超过这个时间而客户端没有任何响应，Nginx将返回一个<span class="string">"Request time out"</span> (408)错误。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">client_max_body_size</span><br><span class="line">语法：client_max_body_size size </span><br><span class="line">默认值：client_max_body_size 1m </span><br><span class="line">使用字段：http, server, location </span><br><span class="line">指令指定允许客户端连接的最大请求实体大小，它出现在请求头部的Content-Length字段。</span><br><span class="line">如果请求大于指定的值，客户端将收到一个<span class="string">"Request Entity Too Large"</span> (413)错误。</span><br><span class="line">记住，浏览器并不知道怎样显示这个错误。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">default_type</span><br><span class="line">语法： default_type MIME-type </span><br><span class="line">默认值：default_type text/plain </span><br><span class="line">使用字段：http, server, location </span><br><span class="line">某个文件在标准MIME视图没有指定的情况下的默认MIME类型。</span><br><span class="line">参考types</span><br><span class="line">location = /proxy.pac &#123;</span><br><span class="line">  default_type application/x-ns-proxy-autoconfig;</span><br><span class="line">&#125;</span><br><span class="line">location = /wpad.dat &#123;</span><br><span class="line">  rewrite . /proxy.pac;</span><br><span class="line">  default_type application/x-ns-proxy-autoconfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">directio</span><br><span class="line">语法：directio [size|off] </span><br><span class="line">默认值：directio off </span><br><span class="line">使用字段：http, server, location </span><br><span class="line">这个参数指定在读取文件大小大于指定值的文件时使用O_DIRECT（FreeBSD, Linux），F_NOCACHE（Mac OS X）或者调用directio()函数（Solaris），当一个请求用到这个参数时会禁用sendfile，通常这个参数用于大文件。</span><br><span class="line">directio  4m;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">error_page</span><br><span class="line">语法：error_page code [ code... ] [ = | =answer-code ] uri | @named_location </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：http, server, location, location 中的<span class="keyword">if</span>字段 </span><br><span class="line">这个参数可以为错误代码指定相应的错误页面</span><br><span class="line">error_page   404          /404.html;</span><br><span class="line">error_page   502 503 504  /50x.html;</span><br><span class="line">error_page   403          http://example.com/forbidden.html;</span><br><span class="line">error_page   404          = @fetch;</span><br><span class="line">同样，你也可以修改返回的错误代码：</span><br><span class="line">error_page 404 =200 /.empty.gif;</span><br><span class="line">如果一个错误的响应经过代理或者FastCGI服务器并且这个服务器可以返回不同的响应码，如200, 302, 401或404，那么可以指定响应码返回：</span><br><span class="line">error_page   404  =  /404.php;</span><br><span class="line">如果在重定向时不需要改变URI，可以将错误页面重定向到一个命名的location字段中：</span><br><span class="line">location / (</span><br><span class="line">    error_page 404 = @fallback;</span><br><span class="line">)</span><br><span class="line">location @fallback (</span><br><span class="line">    proxy_pass http://backend;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if_modified_since</span><br><span class="line">语法：if_modified_since [off|exact|before]</span><br><span class="line">默认值：if_modified_since exact </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">internal</span><br><span class="line">语法：internal </span><br><span class="line">默认值：no </span><br><span class="line">使用字段： location </span><br><span class="line">internal指令指定某个location只能被“内部的”请求调用，外部的调用请求会返回<span class="string">"Not found"</span> (404)</span><br><span class="line">“内部的”是指下列类型：</span><br><span class="line">·指令error_page重定向的请求。</span><br><span class="line">·ngx_http_ssi_module模块中使用include virtual指令创建的某些子请求。</span><br><span class="line">·ngx_http_rewrite_module模块中使用rewrite指令修改的请求。</span><br><span class="line">一个防止错误页面被用户直接访问的例子：</span><br><span class="line">error_page 404 /404.html;</span><br><span class="line">location  /404.html &#123;</span><br><span class="line">  internal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">keepalive_timeout</span><br><span class="line">语法：keepalive_timeout [ time ] [ time ]</span><br><span class="line">默认值：keepalive_timeout 75 </span><br><span class="line">使用字段：http, server, location </span><br><span class="line">参数的第一个值指定了客户端与服务器长连接的超时时间，超过这个时间，服务器将关闭连接。</span><br><span class="line">参数的第二个值（可选）指定了应答头中Keep-Alive: timeout=time的time值，这个值可以使一些浏览器知道什么时候关闭连接，以便服务器不用重复关闭，如果不指定这个参数，nginx不会在应答头中发送Keep-Alive信息。（但这并不是指怎样将一个连接“Keep-Alive”）</span><br></pre></td></tr></table></figure>
<p>参数的这两个值可以不相同<br>下面列出了一些服务器如何处理包含Keep-Alive的应答头：</p>
<pre><code>·MSIE和Opera将Keep-Alive: timeout=N头忽略。
·MSIE保持一个连接大约60-65秒，然后发送一个TCP RST。
·Opera将一直保持一个连接处于活动状态。
·Mozilla将一个连接在N的基础上增加大约1-10秒。
·Konqueror保持一个连接大约N秒。
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keepalive_requests</span><br><span class="line">语法：keepalive_requests n </span><br><span class="line">默认值：keepalive_requests 100 </span><br><span class="line">使用字段：http, server, location </span><br><span class="line">服务器保持长连接的请求数。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">large_client_header_buffers</span><br><span class="line">语法：large_client_header_buffers number size </span><br><span class="line">默认值：large_client_header_buffers 4 4k/8k </span><br><span class="line">使用字段：http, server </span><br><span class="line">指定客户端一些比较大的请求头使用的缓冲区数量和大小。</span><br><span class="line">请求字段不能大于一个缓冲区大小，如果客户端发送一个比较大的头，nginx将返回<span class="string">"Request URI too large"</span> (414)</span><br><span class="line">同样，请求的头部最长字段不能大于一个缓冲区，否则服务器将返回<span class="string">"Bad request"</span> (400)。</span><br><span class="line">缓冲区只在需求时分开。</span><br><span class="line">默认一个缓冲区大小为操作系统中分页文件大小，通常是4k或8k，如果一个连接请求最终将状态转换为keep-alive，它所占用的缓冲区将被释放。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">limit_except</span><br><span class="line">语法：limit_except methods &#123;...&#125; </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：location </span><br><span class="line">指令可以在location字段中做一些http动作的限制。</span><br><span class="line">ngx_http_access_module和ngx_http_auth_basic_module模块有很强的访问控制功能。</span><br><span class="line">limit_except  GET &#123;</span><br><span class="line">  allow  192.168.1.0/32;</span><br><span class="line">  deny   all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">limit_rate</span><br><span class="line">语法：limit_rate speed </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：http, server, location, location中的<span class="keyword">if</span>字段 </span><br><span class="line">限制将应答传送到客户端的速度，单位为字节/秒，限制仅对一个连接有效，即如果一个客户端打开2个连接，则它的速度是这个值乘以二。</span><br><span class="line">由于一些不同的状况，可能要在server字段来限制部分连接的速度，那么这个参数并不适用，不过你可以选择设置<span class="variable">$limit_rate</span>变量的值来达到目的：</span><br><span class="line">server &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">$slow</span>) &#123;</span><br><span class="line">    <span class="built_in">set</span> <span class="variable">$limit_rate</span>  4k;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">同样可以通过设置X-Accel-Limit-Rate头（NginxXSendfile）来控制proxy_pass返回的应答。并且不借助X-Accel-Redirect头来完成。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">limit_rate_after</span><br><span class="line">语法：limit_rate_after time </span><br><span class="line">默认值：limit_rate_after 1m </span><br><span class="line">使用字段：http, server, location, location中的<span class="keyword">if</span>字段 </span><br><span class="line">在应答一部分被传递后限制速度：</span><br><span class="line">limit_rate_after 1m;</span><br><span class="line">limit_rate 100k;</span><br><span class="line"></span><br><span class="line">listen</span><br><span class="line">默认值：listen 80 </span><br><span class="line">使用字段：server </span><br><span class="line">listen指令指定了server&#123;...&#125;字段中可以被访问到的ip地址及端口号，可以只指定一个ip，一个端口，或者一个可解析的服务器名。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location</span><br><span class="line">语法：location [=|~|~*|^~|@] /uri/ &#123; ... &#125; </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：server</span><br></pre></td></tr></table></figure>
<p>这个参数根据URI的不同需求来进行配置，可以使用字符串与正则表达式匹配，如果要使用正则表达式，你必须指定下列前缀：</p>
<pre><code>1、~* 不区分大小写。
2、~ 区分大小写。
</code></pre><p>要确定该指令匹配特定的查询，程序将首先对字符串进行匹配，字符串匹配将作为查询的开始，最确切的匹配将被使用。然后，正则表达式的匹配查询开始，匹配查询的第一个正则表达式找到后会停止搜索，如果没有找到正则表达式，将使用字符串的搜索结果。<br>在一些操作系统，如Mac OS X和Cygwin，字符串将通过不区分大小写的方式完成匹配（0.7.7），但是，比较仅限于单字节的语言环境。<br>正则表达式可以包含捕获（0.7.40），并用于其它指令中。<br>可以使用“^~”标记禁止在字符串匹配后检查正则表达式，如果最确切的匹配location有这个标记，那么正则表达式不会被检查。<br>使用“=”标记可以在URI和location之间定义精确的匹配，在精确匹配完成后并不进行额外的搜索，例如有请求“/”发生，则可以使用“location = /”来加速这个处理。<br>即使没有“=”和“^~”标记，精确的匹配location在找到后同样会停止查询。<br>下面是各种查询方式的总结：</p>
<pre><code>1、前缀“=”表示精确匹配查询，如果找到，立即停止查询。
2、指令仍然使用标准字符串，如果匹配使用“^~”前缀，停止查询。
3、正则表达式按照他们在配置文件中定义的顺序。
4、如果第三条产生一个匹配，这个匹配将被使用，否则将使用第二条的匹配。
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_not_found</span><br><span class="line">语法：log_not_found [on|off] </span><br><span class="line">默认值：log_not_found on </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure>
<p>指令指定是否将一些文件没有找到的错误信息写入error_log指定的文件中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_subrequest</span><br><span class="line">语法：log_subrequest [on|off]</span><br><span class="line">默认值：log_subrequest off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>指令指定是否将一些经过rewrite rules和/或SSI requests的子请求日志写入access_log指定的文件中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msie_padding</span><br><span class="line">语法：msie_padding [on|off] </span><br><span class="line">默认值：msie_padding on </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>指令指定开启或关闭MSIE浏览器和chrome浏览器（0.8.25+）的msie_padding特征，当这个功能开启，nginx将为响应实体分配最小512字节，以便响应大于或等于400的状态代码。<br>指令预防在MSIE和chrome浏览器中激活“友好的”HTTP错误页面，以便不在服务器端隐藏更多的错误信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msie_refresh</span><br><span class="line">语法： msie_refresh [on|off] </span><br><span class="line">默认值：msie_refresh off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>指令允许或拒绝为MSIE发布一个refresh而不是做一次redirect<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open_file_cache</span><br><span class="line">语法：open_file_cache max = N [inactive = time] | off </span><br><span class="line">默认值：open_file_cache off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>这个指令指定缓存是否启用，如果启用，将记录文件以下信息：</p>
<pre><code>·打开的文件描述符，大小信息和修改时间。
·存在的目录信息。
·在搜索文件过程中的错误信息 -- 没有这个文件、无法正确读取，参考open_file_cache_errors
</code></pre><p>指令选项：</p>
<pre><code>·max - 指定缓存的最大数目，如果缓存溢出，最长使用过的文件（LRU）将被移除。
·inactive - 指定缓存文件被移除的时间，如果在这段时间内文件没被下载，默认为60秒。
·off - 禁止缓存。
</code></pre><p>例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open_file_cache max=1000 inactive=20s;</span><br><span class="line">open_file_cache_valid    30s;</span><br><span class="line">open_file_cache_min_uses 2;</span><br><span class="line">open_file_cache_errors   on;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open_file_cache_errors</span><br><span class="line">语法：open_file_cache_errors on | off </span><br><span class="line">默认值：open_file_cache_errors off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure>
<p>这个指令指定是否在搜索一个文件是记录cache错误。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open_file_cache_min_uses</span><br><span class="line">语法：open_file_cache_min_uses number </span><br><span class="line">默认值：open_file_cache_min_uses 1 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数，如果使用更大的值，文件描述符在cache中总是打开状态。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open_file_cache_valid</span><br><span class="line">语法：open_file_cache_valid time </span><br><span class="line">默认值：open_file_cache_valid 60 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">optimize_server_names</span><br><span class="line">语法：optimize_server_names [ on|off ] </span><br><span class="line">默认值：optimize_server_names on </span><br><span class="line">使用字段：http, server</span><br></pre></td></tr></table></figure></p>
<p>这个指令指定是否在基于域名的虚拟主机中开启最优化的主机名检查。<br>尤其是检查影响到使用主机名的重定向，如果开启最优化，那么所有基于域名的虚拟主机监听的一个“地址：端口对”具有相同的配置，这样在请求执行的时候并不进行再次检查，重定向会使用第一个server name。<br>如果重定向必须使用主机名并且在客户端检查通过，那么这个参数必须设置为off。<br>注意：这个参数不建议在nginx 0.7.x版本中使用，请使用server_name_in_redirect。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">port_in_redirect</span><br><span class="line">语法：port_in_redirect [ on|off ] </span><br><span class="line">默认值：port_in_redirect on </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>这个指令指定是否在让nginx在重定向操作中对端口进行操作。<br>如果这个指令设置为off，在重定向的请求中nginx不会在url中添加端口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">recursive_error_pages</span><br><span class="line">语法：recursive_error_pages [on|off] </span><br><span class="line">默认值：recursive_error_pages off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>recursive_error_pages指定启用除第一条error_page指令以外其他的error_page。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resolver</span><br><span class="line">语法：resolver address </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>指定DNS服务器地址，如：<br>resolver 127.0.0.1;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resolver_timeout</span><br><span class="line">语法：resolver_timeout time </span><br><span class="line">默认值：30s </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>解析超时时间。如：<br>resolver_timeout 5s;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">语法：root path </span><br><span class="line">默认值：root html </span><br><span class="line">使用字段：http, server, location ,location中的<span class="keyword">if</span>字段</span><br></pre></td></tr></table></figure></p>
<p>请求到达后的文件根目录。<br>下例中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location  /i/ &#123;</span><br><span class="line">  root  /spool/w3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果请求”/i/top.gif”文件，nginx将转到”/spool/w3/i/top.gif”文件。你可以在参数中使用变量。<br>注意：在请求中root会添加这个location到它的值后面，即”/i/top.gif”并不会请求”/spool/w3/top.gif”文件，如果要实现上述类似于apache alias的功能，可以使用alias指令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">satisfy_any</span><br><span class="line">语法：satisfy_any [ on|off ] </span><br><span class="line">默认值：satisfy_any off </span><br><span class="line">使用字段：location</span><br></pre></td></tr></table></figure></p>
<p>指令可以检查至少一个成功的密码效验，它在NginxHttpAccessModule或NginxHttpAuthBasicModule这两个模块中执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  satisfy_any  on;</span><br><span class="line">  allow  192.168.1.0/32;</span><br><span class="line">  deny   all;</span><br><span class="line">  auth_basic            <span class="string">"closed site"</span>;</span><br><span class="line">  auth_basic_user_file  conf/htpasswd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">send_timeout</span><br><span class="line">语法：send_timeout the time </span><br><span class="line">默认值：send_timeout 60 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure>
<p>指令指定了发送给客户端应答后的超时时间，Timeout是指没有进入完整established状态，只完成了两次握手，如果超过这个时间客户端没有任何响应，nginx将关闭连接。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sendfile</span><br><span class="line">语法：sendfile [ on|off ] </span><br><span class="line">默认值：sendfile off</span><br></pre></td></tr></table></figure></p>
<p>使用字段：http, server, location<br>是否启用sendfile()函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">语法：server &#123;...&#125; </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：http</span><br></pre></td></tr></table></figure></p>
<p>server字段包含虚拟主机的配置。<br>没有明确的机制来分开基于域名（请求中的主机头）和基于IP的虚拟主机。<br>可以通过listen指令来指定必须连接到这个server块的所有地址和端口，并且在server_name指令中可以指定所有的域名。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server_name</span><br><span class="line">语法：server_name name [... ] </span><br><span class="line">默认值：server_name hostname </span><br><span class="line">使用字段：server</span><br></pre></td></tr></table></figure></p>
<p>这个指令作用：<br>将HTTP请求的主机头与在nginx配置文件中的server{…}字段中指定的参数进行匹配，并且找出第一个匹配结果。这就是如何定义虚拟主机的方法，域名遵循下述优先级规则：</p>
<pre><code>1、完整匹配的名称。
2、名称开始于一个文件通配符：*.example.com。
3、名称结束于一个文件通配符：www.example.*。
4、使用正则表达式的名称。
</code></pre><p>如果没有匹配的结果，nginx配置文件将安装以下优先级使用[#server server { … }]字段：</p>
<pre><code>1、listen指令被标记为default的server字段。
2、第一个出现listen（或者默认的listen 80）的server字段。
</code></pre><p>如果server_name_in_redirect被设置，这个指令将用于设置HTTP重定向的服务器名。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server_name_in_redirect</span><br><span class="line">语法：server_name_in_redirect on|off </span><br><span class="line">默认值：server_name_in_redirect on </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>如果这个指令打开，nginx将使用server_name指定的基本服务器名作为重定向地址，如果关闭，nginx将使用请求中的主机头。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server_names_hash_max_size</span><br><span class="line">语法：server_names_hash_max_size number </span><br><span class="line">默认值：server_names_hash_max_size 512 </span><br><span class="line">使用字段：http</span><br></pre></td></tr></table></figure></p>
<p>服务器名称哈希表的最大值，更多信息请参考nginx Optimizations。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server_names_hash_bucket_size</span><br><span class="line">语法：server_names_hash_bucket_size number </span><br><span class="line">默认值：server_names_hash_bucket_size 32/64/128 </span><br><span class="line">使用字段：http</span><br></pre></td></tr></table></figure></p>
<p>服务器名称哈希表每个页框的大小，这个指令的默认值依赖于cpu缓存。更多信息请参考nginx Optimizations。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server_tokens</span><br><span class="line">语法：server_tokens on|off </span><br><span class="line">默认值：server_tokens on </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>是否在错误页面和服务器头中输出nginx版本信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcp_nodelay</span><br><span class="line">语法：tcp_nodelay [on|off] </span><br><span class="line">默认值：tcp_nodelay on </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>这个指令指定是否使用socket的TCP_NODELAY选项，这个选项只对keep-alive连接有效。<br>点击这里了解更多关于TCP_NODELAY选项的信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcp_nopush</span><br><span class="line">语法：tcp_nopush [on|off] </span><br><span class="line">默认值：tcp_nopush off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>这个指令指定是否使用socket的TCP_NOPUSH（FreeBSD）或TCP_CORK（linux）选项，这个选项只在使用sendfile时有效。<br>设置这个选项的将导致nginx试图将它的HTTP应答头封装到一个包中。<br>点击这里查看关于TCP_NOPUSH和TCP_CORK选项的更多信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try_files</span><br><span class="line">语法：try_files file1 [file2 ... filen] fallback </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：location</span><br></pre></td></tr></table></figure></p>
<p>这个指令告诉nginx将测试参数中每个文件的存在，并且URI将使用第一个找到的文件，如果没有找到文件，将请求名为fallback（可以使任何名称）的location字段，fallback是一个必须的参数，它可以是一个命名的location或者可靠的URI。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">types</span><br><span class="line">语法：types &#123;...&#125; </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>这个字段指定一些扩展的文件对应方式与应答的MIME类型，一个MIME类型可以有一些与其类似的扩展。默认使用以下文件对应方式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">types &#123;</span><br><span class="line">  text/html    html;</span><br><span class="line">  image/gif    gif;</span><br><span class="line">  image/jpeg   jpg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整的对应视图文件为conf/mime.types，并且将被包含。<br>如果你想让某些特定的location的处理方式使用MIME类型：application/octet-stream，可以使用以下配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /download/ &#123;</span><br><span class="line">  types         &#123; &#125;</span><br><span class="line">  default_type  application/octet-stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>变量</strong><br>core module 支持一些内置的变量，与apache使用的变量相一致。<br>首先，一些变量代表了客户端请求头部的一些字段，如：$http_user_agent, $http_cookie等等。注意，由于这些变量会在请求中定义，所以可能无法保证他们是存在的或者说可以定义到一些别的地方（例如遵循一定的规范）。<br>一些其他变量：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$arg_PARAMETER</span></span><br><span class="line">这个变量包含在查询字符串时GET请求PARAMETER的值。</span><br><span class="line"><span class="variable">$args</span></span><br><span class="line">这个变量等于请求行中的参数。</span><br><span class="line"><span class="variable">$binary_remote_addr</span></span><br><span class="line">二进制码形式的客户端地址。</span><br><span class="line"><span class="variable">$content_length</span></span><br><span class="line">请求头中的Content-length字段。</span><br><span class="line"><span class="variable">$content_type</span></span><br><span class="line">请求头中的Content-Type字段。</span><br><span class="line"><span class="variable">$cookie_COOKIE</span></span><br><span class="line">cookie COOKIE的值。</span><br><span class="line"><span class="variable">$document_root</span></span><br><span class="line">当前请求在root指令中指定的值。</span><br><span class="line"><span class="variable">$document_uri</span></span><br><span class="line">与<span class="variable">$uri</span>相同。</span><br><span class="line"><span class="variable">$host</span></span><br><span class="line">请求中的主机头字段，如果请求中的主机头不可用，则为服务器处理请求的服务器名称。</span><br><span class="line"><span class="variable">$is_args</span></span><br><span class="line">如果<span class="variable">$args</span>设置，值为<span class="string">"?"</span>，否则为<span class="string">""</span>。</span><br><span class="line"><span class="variable">$limit_rate</span></span><br><span class="line">这个变量可以限制连接速率。</span><br><span class="line"><span class="variable">$nginx_version</span></span><br><span class="line">当前运行的nginx版本号。</span><br><span class="line"><span class="variable">$query_string</span></span><br><span class="line">与<span class="variable">$args</span>相同。</span><br><span class="line"><span class="variable">$remote_addr</span></span><br><span class="line">客户端的IP地址。</span><br><span class="line"><span class="variable">$remote_port</span></span><br><span class="line">客户端的端口。</span><br><span class="line"><span class="variable">$remote_user</span></span><br><span class="line">已经经过Auth Basic Module验证的用户名。</span><br><span class="line"><span class="variable">$request_filename</span></span><br><span class="line">当前连接请求的文件路径，由root或<span class="built_in">alias</span>指令与URI请求生成。</span><br><span class="line"><span class="variable">$request_body</span></span><br><span class="line">这个变量包含请求的主要信息。在使用proxy_pass或fastcgi_pass指令的location中比较有意义。</span><br><span class="line"><span class="variable">$request_body_file</span></span><br><span class="line">客户端请求主体信息的临时文件名。</span><br><span class="line"><span class="variable">$request_method</span></span><br><span class="line">这个变量是客户端请求的动作，通常为GET或POST。</span><br><span class="line">包括0.8.20及之前的版本中，这个变量总为main request中的动作，如果当前请求是一个子请求，并不使用这个当前请求的动作。</span><br><span class="line"><span class="variable">$request_uri</span></span><br><span class="line">这个变量等于包含一些客户端请求参数的原始URI，它无法修改，请查看<span class="variable">$uri</span>更改或重写URI。</span><br><span class="line"><span class="variable">$scheme</span></span><br><span class="line">HTTP方法（如http，https）</span><br><span class="line"><span class="variable">$server_addr</span></span><br><span class="line">服务器地址，在完成一次系统调用后可以确定这个值，如果要绕开系统调用，则必须在listen中指定地址并且使用<span class="built_in">bind</span>参数。</span><br><span class="line"><span class="variable">$server_name</span></span><br><span class="line">服务器名称</span><br><span class="line"><span class="variable">$server_port</span></span><br><span class="line">请求到达服务器的端口号。</span><br><span class="line"><span class="variable">$server_protocol</span></span><br><span class="line">请求使用的协议，通常是HTTP/1.0或HTTP/1.1。</span><br><span class="line"><span class="variable">$uri</span></span><br><span class="line">请求中的当前URI(不带请求参数，参数位于<span class="variable">$args</span>)，可以不同于浏览器传递的<span class="variable">$request_uri</span>的值，它可以通过内部重定向，或者使用index指令进行修改。</span><br></pre></td></tr></table></figure></p>
<h4 id="HTTP负载均衡模块"><a href="#HTTP负载均衡模块" class="headerlink" title="HTTP负载均衡模块"></a>HTTP负载均衡模块</h4><p>这个模块为后端的服务器提供简单的负载均衡（轮询（round-robin）和连接IP（client IP））<br>如下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">upstream backend  &#123;</span><br><span class="line">  server backend1.example.com weight=5;</span><br><span class="line">  server backend2.example.com:8080;</span><br><span class="line">  server unix:/tmp/backend3;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">server &#123;</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass  http://backend;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip_hash</span><br><span class="line">语法：ip_hash </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：upstream</span><br></pre></td></tr></table></figure></p>
<p>这个指令将基于客户端连接的IP地址来分发请求。<br>哈希的关键字是客户端的C类网络地址，这个功能将保证这个客户端请求总是被转发到一台服务器上，但是如果这台服务器不可用，那么请求将转发到另外的服务器上，这将保证某个客户端有很大概率总是连接到一台服务器。<br>无法将权重（weight）与ip_hash联合使用来分发连接。如果有某台服务器不可用，你必须标记其为“down”，如下例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  server   backend1.example.com;</span><br><span class="line">  server   backend2.example.com;</span><br><span class="line">  server   backend3.example.com  down;</span><br><span class="line">  server   backend4.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">语法：server name [parameters] </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：upstream</span><br></pre></td></tr></table></figure>
<p>指定后端服务器的名称和一些参数，可以使用域名，IP，端口，或者unix socket。如果指定为域名，则首先将其解析为IP。</p>
<pre><code>weight = NUMBER - 设置服务器权重，默认为1。
max_fails = NUMBER - 在一定时间内（这个时间在fail_timeout参数中设置）检查这个服务器是否可用时产生的最多失败请求数，默认为1，将其设置为0可以关闭检查，这些错误在proxy_next_upstream或fastcgi_next_upstream（404错误不会使max_fails增加）中定义。
fail_timeout = TIME - 在这个时间内产生了max_fails所设置大小的失败尝试连接请求后这个服务器可能不可用，同样它指定了服务器不可用的时间（在下一次尝试连接请求发起之前），默认为10秒，fail_timeout与前端响应时间没有直接关系，不过可以使用proxy_connect_timeout和proxy_read_timeout来控制。
down - 标记服务器处于离线状态，通常和ip_hash一起使用。
backup - (0.6.7或更高)如果所有的非备份服务器都宕机或繁忙，则使用本服务器（无法和ip_hash指令搭配使用）。
</code></pre><p>示例配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream  backend  &#123;</span><br><span class="line">  server   backend1.example.com    weight=5;</span><br><span class="line">  server   127.0.0.1:8080          max_fails=3  fail_timeout=30s;</span><br><span class="line">  server   unix:/tmp/backend3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：如果你只使用一台上游服务器，nginx将设置一个内置变量为1，即max_fails和fail_timeout参数不会被处理。<br>结果：如果nginx不能连接到上游，请求将丢失。<br>解决：使用多台上游服务器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream</span><br><span class="line">语法：upstream name &#123; ... &#125; </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：http</span><br></pre></td></tr></table></figure></p>
<p>这个字段设置一群服务器，可以将这个字段放在proxy_pass和fastcgi_pass指令中作为一个单独的实体，它们可以可以是监听不同端口的服务器，并且也可以是同时监听TCP和Unix socket的服务器。<br>服务器可以指定不同的权重，默认为1。<br>示例配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">  server backend1.example.com weight=5;</span><br><span class="line">  server 127.0.0.1:8080       max_fails=3  fail_timeout=30s;</span><br><span class="line">  server unix:/tmp/backend3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请求将按照轮询的方式分发到后端服务器，但同时也会考虑权重。<br>在上面的例子中如果每次发生7个请求，5个请求将被发送到backend1.example.com，其他两台将分别得到一个请求，如果有一台服务器不可用，那么请求将被转发到下一台服务器，直到所有的服务器检查都通过。如果所有的服务器都无法通过检查，那么将返回给客户端最后一台工作的服务器产生的结果。<br><strong>变量</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$upstream_addr</span></span><br><span class="line">前端服务器处理请求的服务器地址</span><br><span class="line"><span class="variable">$upstream_status</span></span><br><span class="line">前端服务器的响应状态。</span><br><span class="line"><span class="variable">$upstream_response_time</span></span><br><span class="line">前端服务器的应答时间，精确到毫秒，不同的应答以逗号和冒号分开。</span><br><span class="line"><span class="variable">$upstream_http_</span><span class="variable">$HEADER</span></span><br><span class="line">随意的HTTP协议头</span><br></pre></td></tr></table></figure></p>
<h4 id="HTTP访问控制模块"><a href="#HTTP访问控制模块" class="headerlink" title="HTTP访问控制模块"></a>HTTP访问控制模块</h4><p>这个模块提供简单的基于主机的访问控制。<br>ngx_http_access_module这个模块可以详细的检查客户端IP，并且按顺序执行第一条匹配的规则。<br>如下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  deny    192.168.1.1;</span><br><span class="line">  allow   192.168.1.0/24;</span><br><span class="line">  allow   10.1.1.0/16;</span><br><span class="line">  deny    all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子中仅允许192.168.1.0/24和10.1.1.0/16网络段访问，但192.168.1.1是个例外。<br>如果要实施很多复杂的规则，那么最好使用GeoIP module模块。<br><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Allow</span><br><span class="line">语法：allow [ address | CIDR | all ] </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：http, server, location, limit_except</span><br></pre></td></tr></table></figure></p>
<p>指令指定了允许访问的IP或网络段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deny</span><br><span class="line">语法：deny [ address | CIDR | all ] </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：http, server, location, limit_except</span><br></pre></td></tr></table></figure></p>
<p>指令指定了拒绝访问的IP或网络段。<br>提示和技巧：<br>HttpAccess模块可以和error_page指令搭配使用来重定向一个未经验证的访问请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error_page  403  http://example.com/forbidden.html;</span><br><span class="line">location / &#123;</span><br><span class="line">  deny    192.168.1.1;</span><br><span class="line">  allow   192.168.1.0/24;</span><br><span class="line">  allow   10.1.1.0/16;</span><br><span class="line">  deny    all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="HTTP基本认证模块"><a href="#HTTP基本认证模块" class="headerlink" title="HTTP基本认证模块"></a>HTTP基本认证模块</h4><p>这个模块提供基于用户名与密码的验证来保护你的站点或站点的一部分。<br>如下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location  /  &#123;</span><br><span class="line">  auth_basic            <span class="string">"Restricted"</span>;</span><br><span class="line">  auth_basic_user_file  conf/htpasswd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auth_basic</span><br><span class="line">语法：auth_basic [ text|off ] </span><br><span class="line">默认值：auth_basic off </span><br><span class="line">使用字段：http, server, location, limit_except</span><br></pre></td></tr></table></figure></p>
<p>指令包含一个具有测试用户名和密码的HTTP基本认证，指定的参数将用于认证域。如果将值设置为“off”则忽略下级指令继承的动作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auth_basic_user_file</span><br><span class="line">语法：auth_basic_user_file the_file </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：http, server, location, limit_except</span><br></pre></td></tr></table></figure></p>
<h4 id="HTTP目录清单生成模块"><a href="#HTTP目录清单生成模块" class="headerlink" title="HTTP目录清单生成模块"></a>HTTP目录清单生成模块</h4><p>这个模块提供自动目录列表。<br>连接请求仅在ngx_http_index_module中没有找到主页文件时才会请求这个模块。<br>如下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location  /  &#123;</span><br><span class="line">  autoindex  on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">autoindex</span><br><span class="line">语法：autoindex [ on|off ] </span><br><span class="line">默认值：autoindex off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>是否使用自动目录列表。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">autoindex_exact_size</span><br><span class="line">语法：autoindex_exact_size [ on|off ] </span><br><span class="line">默认值：autoindex_exact_size on </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>指定生成的自动目录文件大小，可以是精确到bytes或者使用KB, MB或GB。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">autoindex_localtime</span><br><span class="line">语法：autoindex_localtime [ on|off ] </span><br><span class="line">默认值：autoindex_localtime off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>是否在目录列表文件中显示本地时间（GMT时间），默认为关。</p>
<h4 id="浏览器相关模块"><a href="#浏览器相关模块" class="headerlink" title="浏览器相关模块"></a>浏览器相关模块</h4><p>这个模块按照请求头中的“User-agent”来创建一些变量：</p>
<pre><code>$modern_browser - 如果浏览器被识别为一个当前流行的浏览器，这个值等于指令modern_browser_value指定的值。
$ancient_browser - 如果浏览器被识别为一个比较旧的浏览器，这个值等于指令ancient_browser_value指定的值。
$msie - 如果浏览器被识别为MSIE，这个值为1。
</code></pre><p>如果不需要这个模块，可以在编译nginx时增加–without-http_browser_module参数。<br><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ancient_browser</span><br><span class="line">语法：ancient_browser line [ line... ] </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>在”User-agent”字段中的浏览器被识别为旧浏览器时，这个指令指定一些子链。<br>一个比较特殊的字段是”netscape4”，它对应正则表达式”^Mozilla/[1-4] “。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ancient_browser_value</span><br><span class="line">语法：ancient_browser_value line </span><br><span class="line">默认值：ancient_browser_value 1 </span><br><span class="line">使用字段：http, server, location </span><br><span class="line">指定变量<span class="variable">$ancient_browser</span>的值。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modern_browser</span><br><span class="line">语法：modern_browser browser version|unlisted </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure>
<p>指令将指定哪个版本的浏览器将被认为是目前流行的。<br>可以指定的浏览器为：msie, gecko (基于Mozilla的浏览器) opera, safari, konqueror。<br>可以使用的版本格式为X, X.X, X.X.X, 或X.X.X.X，每个的最大值为4000, 4000.99, 4000.99.99,和4000.99.99.99。<br>一个特殊的值”unlisted”在被认为是流行的浏览器中指定，而不是通过modern_browser或ancient_browser指令。<br>如果请求头中没有”User-agent”字段，那么这个浏览器被认为是古老的（除非指定“modern_browser unlisted”）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modern_browser_value</span><br><span class="line">语法：modern_browser_value line </span><br><span class="line">默认值：modern_browser_value 1 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>指定$modern_browser变量的值。</p>
<h4 id="字符集设置模块"><a href="#字符集设置模块" class="headerlink" title="字符集设置模块"></a>字符集设置模块</h4><p>这个模块将在应答头中为”Content-Type”字段添加字符编码。<br>此外，这个模块可以将数据重新编码，只能在单向对其进行重新编码，即来自服务器到达客户端。<br><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">charset</span><br><span class="line">语法：charset encoding|off </span><br><span class="line">默认值：charset off </span><br><span class="line">使用字段：http, server, location, location中的<span class="keyword">if</span>字段</span><br></pre></td></tr></table></figure></p>
<p>这个指令使应答头中的”Content-Type”字段使用指定的编码集，如果这个字符集与source_charset指令设置的字符集不相同，将重新编码字符集，参数off表明不在应答头中添加”Content-Type”信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">charset_map</span><br><span class="line">语法：charset_map encoding1 encoding2 &#123;...&#125; </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>charset_map指定了一个编码转换表，同时会创建一个反向转换表，代码均使用十六进制，如果在80-FF范围内没有被记录的代码，它们将被标记为”？”。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">override_charset</span><br><span class="line">语法：override_charset on|off </span><br><span class="line">默认值：override_charset off </span><br><span class="line">使用字段：http, server, location, <span class="keyword">if</span>中的location字段</span><br></pre></td></tr></table></figure></p>
<p>参数指定在代理服务器或者FastCGI服务器上取得的应答头中存在”Content-Type”字段，将为应答启用编码转换，如果允许编码转换，将使用应答头中指定的编码对其初始化。<br>注意如果是在一个子查询中取得的应答，会始终将应答中的编码转换为基础编码，并不依赖于override_charset指令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source_charset</span><br><span class="line">语法：source_charset encoding </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：http, server, location, <span class="keyword">if</span>中的location字段</span><br></pre></td></tr></table></figure></p>
<p>参数指定了应答中的初始代码，如果这个参数与charset指令中的不同，将启用编码转换</p>
<h4 id="Empty-GIF模块"><a href="#Empty-GIF模块" class="headerlink" title="Empty GIF模块"></a>Empty GIF模块</h4><p>这个模块在内存中保存一个能够很快传递的1×1透明GIF。<br>简单用法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location = /_.gif &#123;</span><br><span class="line">  empty_gif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">empty_gif</span><br><span class="line">语法：empty_gif </span><br><span class="line">默认值：n/a </span><br><span class="line">使用字段：location</span><br></pre></td></tr></table></figure></p>
<h4 id="FastCGI模块"><a href="#FastCGI模块" class="headerlink" title="FastCGI模块"></a>FastCGI模块</h4><p>这个模块允许nginx同FastCGI协同工作，并且控制哪些参数将被安全传递。<br><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_buffer_size</span><br><span class="line">语法：fastcgi_buffer_size the_size ;</span><br><span class="line">默认值：fastcgi_buffer_size 4k/8k ;</span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>这个参数指定将用多大的缓冲区来读取从FastCGI服务器到来应答的第一部分。<br>通常来说在这个部分中包含一个小的应答头。<br>默认的缓冲区大小为fastcgi_buffers指令中的每块大小，可以将这个值设置更小。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_buffers</span><br><span class="line">语法：fastcgi_buffers the_number is_size; </span><br><span class="line">默认值：fastcgi_buffers 8 4k/8k; </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>这个参数指定了从FastCGI服务器到来的应答，本地将用多少和多大的缓冲区读取，默认这个参数等于分页大小，根据环境的不同可能是4K, 8K或16K。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_cache</span><br><span class="line">语法：fastcgi_cache zone|off; </span><br><span class="line">默认值：off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>为缓存实际使用的共享内存指定一个区域，相同的区域可以用在不同的地方。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_cache_key</span><br><span class="line">语法：fastcgi_cache_key line</span><br><span class="line">默认值：none </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>设置缓存的关键字，如：<br>fastcgi_cache_key localhost:9000$request_uri;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_cache_path</span><br><span class="line">语法：fastcgi_cache_path path [levels=m:n] keys_zone=name:size [inactive=time] [max_size=size] </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：http</span><br></pre></td></tr></table></figure></p>
<p>clean_time参数在0.7.45版本中已经移除。<br>这个指令指定FastCGI缓存的路径以及其他的一些参数，所有的数据以文件的形式存储，缓存的关键字(key)和文件名为代理的url计算出的MD5值。<br>Level参数设置缓存目录的目录分级以及子目录的数量，例如指令如果设置为：<br>fastcgi_cache_path  /data/nginx/cache  levels=1:2   keys_zone=one:10m;<br>那么数据文件将存储为：<br>/data/nginx/cache/c/29/b7f54b2df7773722d382f4809d65029c<br>缓存中的文件首先被写入一个临时文件并且随后被移动到缓存目录的最后位置，0.8.9版本之后可以将临时文件和缓存文件存储在不同的文件系统，但是需要明白这种移动并不是简单的原子重命名系统调用，而是整个文件的拷贝，所以最好在fastcgi_temp_path和fastcgi_cache_path的值中使用相同的文件系统。<br>另外，所有活动的关键字及数据相关信息都存储于共享内存池，这个值的名称和大小通过key_zone参数指定，inactive参数指定了内存中的数据存储时间，默认为10分钟。<br>max_size参数设置缓存的最大值，一个指定的cache manager进程将周期性的删除旧的缓存数据。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_cache_methods</span><br><span class="line">语法：fastcgi_cache_methods [GET HEAD POST]; </span><br><span class="line">默认值：fastcgi_cache_methods GET HEAD; </span><br><span class="line">使用字段：main,http,location</span><br></pre></td></tr></table></figure></p>
<p>无法禁用GET/HEAD ，即使你只是这样设置：<br>fastcgi_cache_methods  POST;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_cache_min_uses</span><br><span class="line">语法：fastcgi_cache_min_uses n </span><br><span class="line">默认值：fastcgi_cache_min_uses 1 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>指令指定了经过多少次请求的相同URL将被缓存。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_cache_path</span><br><span class="line">语法：fastcgi_cache_path /path/to/cache [levels=m:n keys_zone=name:time inactive=time] </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：http</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_cache_use_stale</span><br><span class="line">语法：fastcgi_cache_use_stale [updating|error|timeout|invalid_header|http_500] </span><br><span class="line">默认值：fastcgi_cache_use_stale off; </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_cache_valid</span><br><span class="line">语法：fastcgi_cache_valid [http_error_code|time] </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure>
<p>为指定的http返回代码指定缓存时间，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_cache_valid  200 302  10m;</span><br><span class="line">fastcgi_cache_valid  404      1m;</span><br></pre></td></tr></table></figure></p>
<p>将响应状态码为200和302缓存10分钟，404缓存1分钟。<br>默认情况下缓存只处理200，301，302的状态。<br>同样也可以在指令中使用any表示任何一个。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_cache_valid  200 302 10m;</span><br><span class="line">fastcgi_cache_valid  301 1h;</span><br><span class="line">fastcgi_cache_valid  any 1m;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_connect_timeout</span><br><span class="line">语法：fastcgi_connect_timeout time </span><br><span class="line">默认值：fastcgi_connect_timeout 60 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure>
<p>指定同FastCGI服务器的连接超时时间，这个值不能超过75秒。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_index</span><br><span class="line">语法：fastcgi_index file </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>如果URI以斜线结尾，文件名将追加到URI后面，这个值将存储在变量$fastcgi_script_name中。例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_index  index.php;</span><br><span class="line">fastcgi_param  SCRIPT_FILENAME  /home/www/scripts/php<span class="variable">$fastcgi_script_name</span>;</span><br></pre></td></tr></table></figure></p>
<p>请求”/page.php”的参数SCRIPT_FILENAME将被设置为”/home/www/scripts/php/page.php”，但是”/“为”/home/www/scripts/php/index.php”。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_hide_header</span><br><span class="line">语法：fastcgi_hide_header name </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>默认情况下nginx不会将来自FastCGI服务器的”Status”和”X-Accel-…”头传送到客户端，这个参数也可以隐藏某些其它的头。<br>如果必须传递”Status”和”X-Accel-…”头，则必须使用fastcgi_pass_header强制其传送到客户端。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_ignore_client_abort</span><br><span class="line">语法：fastcgi_ignore_client_abort on|off </span><br><span class="line">默认值：fastcgi_ignore_client_abort off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>如果当前连接请求FastCGI服务器失败，为防止其与nginx服务器断开连接，可以用这个指令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_ignore_headers</span><br><span class="line">语法：fastcgi_ignore_headers name [name...] </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>这个指令禁止处理一些FastCGI服务器应答的头部字段，比如可以指定像”X-Accel-Redirect”, “X-Accel-Expires”, “Expires”或”Cache-Control”等。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_intercept_errors</span><br><span class="line">语法：fastcgi_intercept_errors on|off </span><br><span class="line">默认值：fastcgi_intercept_errors off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>这个指令指定是否传递4xx和5xx错误信息到客户端，或者允许nginx使用error_page处理错误信息。<br>你必须明确的在error_page中指定处理方法使这个参数有效，正如Igor所说“如果没有适当的处理方法，nginx不会拦截一个错误，这个错误不会显示自己的默认页面，这里允许通过某些方法拦截错误。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_max_temp_file_size</span><br><span class="line">语法：fastcgi_max_temp_file_size 0 </span><br><span class="line">默认值：fastcgi_max_temp_file_size 0 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>根据源代码关闭FastCGI缓冲。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_no_cache</span><br><span class="line">语法：fastcgi_no_cache variable [...]</span><br><span class="line">默认值：None </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>确定在何种情况下缓存的应答将不会使用，示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_no_cache $cookie_nocache  $arg_nocache$arg_comment;</span><br><span class="line">fastcgi_no_cache $http_pragma     $http_authorization;</span><br></pre></td></tr></table></figure></p>
<p>如果为空字符串或者等于0，表达式的值等于false，例如，在上述例子中，如果在请求中设置了cookie “nocache”，缓存将被绕过。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_next_upstream</span><br><span class="line">语法：fastcgi_next_upstream error|timeout|invalid_header|http_500|http_503|http_404|off </span><br><span class="line">默认值：fastcgi_next_upstream error timeout </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>指令指定哪种情况请求将被转发到下一个FastCGI服务器：</p>
<pre><code>error — 传送中的请求或者正在读取应答头的请求在连接服务器的时候发生错误。
timeout — 传送中的请求或者正在读取应答头的请求在连接服务器的时候超时。
invalid_header — 服务器返回空的或者无效的应答。
http_500 — 服务器返回500应答代码。
http_503 — 服务器返回503应答代码。
http_404 — 服务器返回404应答代码。
off — 禁止请求传送到下一个FastCGI服务器。
</code></pre><p>注意传送请求在传送到下一个服务器之前可能已经将空的数据传送到了客户端，所以，如果在数据传送中有错误或者超时发生，这个指令可能无法修复一些传送错误。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_param</span><br><span class="line">语法：fastcgi_param parameter value </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>指定一些传递到FastCGI服务器的参数。<br>可以使用字符串，变量，或者其组合，这里的设置不会继承到其他的字段，设置在当前字段会清除掉任何之前的定义。<br>下面是一个PHP需要使用的最少参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_param  SCRIPT_FILENAME  /home/www/scripts/php<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">fastcgi_param  QUERY_STRING     <span class="variable">$query_string</span>;</span><br></pre></td></tr></table></figure></p>
<p>PHP使用SCRIPT_FILENAME参数决定需要执行哪个脚本，QUERY_STRING包含请求中的某些参数。<br>如果要处理POST请求，则需要另外增加三个参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_param  REQUEST_METHOD   <span class="variable">$request_method</span>;</span><br><span class="line">fastcgi_param  CONTENT_TYPE     <span class="variable">$content_type</span>;</span><br><span class="line">fastcgi_param  CONTENT_LENGTH   <span class="variable">$content_length</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果PHP在编译时带有–enable-force-cgi-redirect，则必须传递值为200的REDIRECT_STATUS参数：<br>fastcgi_param  REDIRECT_STATUS  200;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_pass</span><br><span class="line">语法：fastcgi_pass fastcgi-server </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_pass_header</span><br><span class="line">语法：fastcgi_pass_header name </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_read_timeout</span><br><span class="line">语法：fastcgi_read_timeout time </span><br><span class="line">默认值：fastcgi_read_timeout 60 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure>
<p>前端FastCGI服务器的响应超时时间，如果有一些直到它们运行完才有输出的长时间运行的FastCGI进程，或者在错误日志中出现前端服务器响应超时错误，可能需要调整这个值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_redirect_errors</span><br><span class="line">语法：fastcgi_redirect_errors on|off</span><br></pre></td></tr></table></figure></p>
<p>指令重命名为fastcgi_intercept_errors。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_send_timeout</span><br><span class="line">语法：fastcgi_send_timeout time </span><br><span class="line">默认值：fastcgi_send_timeout 60 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>指令为上游服务器设置等待一个FastCGI进程的传送数据时间，如果有一些直到它们运行完才有输出的长时间运行的FastCGI进程，那么可以修改这个值，如果你在上有服务器的error log里面发现一些超时错误，那么可以恰当的增加这个值。<br>指令指定请求服务器的超时时间，指完成了2次握手的连接，而不是完整的连接，如果在这期间客户端没有进行数据传递，那么服务器将关闭这个连接。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_split_path_info</span><br><span class="line">语法：fastcgi_split_path_info regex </span><br><span class="line">使用字段：location</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_store</span><br><span class="line">语法：fastcgi_store [on | off | path] </span><br><span class="line">默认值：fastcgi_store off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure>
<p>制定了存储前端文件的路径，参数on指定了将使用root和alias指令相同的路径，off禁止存储，此外，参数中可以使用变量使路径名更明确：<br>fastcgi_store   /data/www$original_uri;<br>应答中的”Last-Modified”头将设置文件的最后修改时间，为了使这些文件更加安全，可以将其在一个目录中存为临时文件，使用fastcgi_temp_path指令。<br>这个指令可以用在为那些不是经常改变的后端动态输出创建本地拷贝的过程中。如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">  root                 /data/www;</span><br><span class="line">  error_page           404 = /fetch<span class="variable">$uri</span>;</span><br><span class="line">&#125;</span><br><span class="line">location /fetch &#123;</span><br><span class="line">  internal;</span><br><span class="line"> </span><br><span class="line">  fastcgi_pass           fastcgi://backend;</span><br><span class="line">  fastcgi_store          on;</span><br><span class="line">  fastcgi_store_access   user:rw  group:rw  all:r;</span><br><span class="line">  fastcgi_temp_path      /data/temp;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">alias</span>                  /data/www;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fastcgi_store并不是缓存，某些需求下它更像是一个镜像。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_store_access</span><br><span class="line">语法：fastcgi_store_access users:permissions [users:permission ...] </span><br><span class="line">默认值：fastcgi_store_access user:rw </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>这个参数指定创建文件或目录的权限，例如：<br>fastcgi_store_access  user:rw  group:rw  all:r;<br>如果要指定一个组的人的相关权限，可以不写用户，如：<br>fastcgi_store_access  group:rw  all:r;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_temp_path</span><br><span class="line">语法：fastcgi_temp_path path [level1 [level2 [level3]]] </span><br><span class="line">默认值：fastcgi_temp_path fastcgi_temp </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p><strong>变量</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$fastcgi_script_name</span></span><br><span class="line">这个变量等于一个以斜线结尾的请求URI加上fastcgi_index给定的参数。可以用这个变量代替SCRIPT_FILENAME 和PATH_TRANSLATED，以确定php脚本的名称。</span><br></pre></td></tr></table></figure></p>
<h4 id="Geo模块"><a href="#Geo模块" class="headerlink" title="Geo模块"></a>Geo模块</h4><p>geo指令使用ngx_http_geo_module模块提供的。默认情况下，nginx有加载这个模块，除非人为的 –without-http_geo_module。ngx_http_geo_module模块可以用来创建变量，其值依赖于客户端IP地址。<br><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">geo </span><br><span class="line">语法: geo [<span class="variable">$address</span>] <span class="variable">$variable</span> &#123; ... &#125;</span><br><span class="line">默认值: —</span><br><span class="line">配置段: http</span><br></pre></td></tr></table></figure></p>
<p>定义从指定的变量获取客户端的IP地址。默认情况下，nginx从$remote_addr变量取得客户端IP地址，但也可以从其他变量获得。如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">geo <span class="variable">$remote_addr</span> <span class="variable">$geo</span> &#123;</span><br><span class="line">        default 0;</span><br><span class="line">        127.0.0.1 1;</span><br><span class="line">&#125;</span><br><span class="line">geo <span class="variable">$arg_ttlsa_com</span> <span class="variable">$geo</span> &#123;</span><br><span class="line">        default 0;</span><br><span class="line">        127.0.0.1 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果该变量的值不能代表一个合法的IP地址，那么nginx将使用地址“255.255.255.255”。<br>nginx通过CIDR或者地址段来描述地址，支持下面几个参数：</p>
<pre><code>delete：删除指定的网络
default：如果客户端地址不能匹配任意一个定义的地址，nginx将使用此值。 如果使用CIDR，可以用“0.0.0.0/0”代替default。
include： 包含一个定义地址和值的文件，可以包含多个。
proxy：定义可信地址。 如果请求来自可信地址，nginx将使用其“X-Forwarded-For”头来获得地址。 相对于普通地址，可信地址是顺序检测的。
proxy_recursive：开启递归查找地址。 如果关闭递归查找，在客户端地址与某个可信地址匹配时，nginx将使用“X-Forwarded-For”中的最后一个地址来代替原始客户端地址。如果开启递归查找，在客户端地址与某个可信地址匹配时，nginx将使用“X-Forwarded-For”中最后一个与所有可信地址都不匹配的地址来代替原始客户端地址。
ranges：使用以地址段的形式定义地址，这个参数必须放在首位。为了加速装载地址库，地址应按升序定义。
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">geo <span class="variable">$country</span> &#123;</span><br><span class="line">    default        ZZ;</span><br><span class="line">    include        conf/geo.conf;</span><br><span class="line">    delete         127.0.0.0/16;</span><br><span class="line">    proxy          192.168.100.0/24;</span><br><span class="line">    proxy          2001:0db8::/32;</span><br><span class="line"> </span><br><span class="line">    127.0.0.0/24   US;</span><br><span class="line">    127.0.0.1/32   RU;</span><br><span class="line">    10.1.0.0/16    RU;</span><br><span class="line">    192.168.1.0/24 UK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim conf/geo.conf</span><br><span class="line">10.2.0.0/16    RU;</span><br><span class="line">192.168.2.0/24 RU;</span><br></pre></td></tr></table></figure>
<p>地址段例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">geo <span class="variable">$country</span> &#123;</span><br><span class="line">    ranges;</span><br><span class="line">    default                   ZZ;</span><br><span class="line">    127.0.0.0-127.0.0.0       US;</span><br><span class="line">    127.0.0.1-127.0.0.1       RU;</span><br><span class="line">    127.0.0.1-127.0.0.255     US;</span><br><span class="line">    10.1.0.0-10.1.255.255     RU;</span><br><span class="line">    192.168.1.0-192.168.1.255 UK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>遵循最精确匹配原则，即nginx使用能最精确匹配客户端地址的值。</p>
<h4 id="Gzip模块"><a href="#Gzip模块" class="headerlink" title="Gzip模块"></a>Gzip模块</h4><p>这个模块允许在文件传输过程中使用gzip压缩。<br><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gzip</span><br><span class="line">语法：gzip on|off </span><br><span class="line">默认值：gzip off </span><br><span class="line">使用字段：http, server, location, location中的<span class="keyword">if</span>字段</span><br></pre></td></tr></table></figure></p>
<p>指定是否启用gzip压缩。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gzip_buffers</span><br><span class="line">语法：gzip_buffers number size </span><br><span class="line">默认值：gzip_buffers 4 4k/8k </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>指定缓存压缩应答的缓冲区数量和大小，如果不设置，一个缓存区的大小为分页大小，根据环境的不同可能是4k或8k。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gzip_comp_level</span><br><span class="line">语法：gzip_comp_level 1..9 </span><br><span class="line">默认值：gzip_comp_level 1 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>指定压缩等级，其值从1到9，1为最小化压缩（处理速度快），9为最大化压缩（处理速度慢）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gzip_disable</span><br><span class="line">语法：gzip_disable regex </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>使用正则表达式来指定某些不需要gzip压缩的浏览器（将和User-Agents进行匹配）。依赖于PCRE库。在0.6.23版本中首次使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gzip_http_version</span><br><span class="line">语法：gzip_http_version 1.0|1.1 </span><br><span class="line">默认值：gzip_http_version 1.1 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>是否根据HTTP请求版本来启用gzip压缩。<br>当HTTP版本为1.0时，Vary: Accept-Encoding没有被设置，这将引起某些代理缓存失效，可以使用add_header，同样，在使用这个版本时Content-Length也没有设置，因此Keepalive不能在这个版本使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gzip_min_length</span><br><span class="line">语法：gzip_min_length length </span><br><span class="line">默认值：gzip_min_length 0 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>设置被压缩的最小请求，单位为bytes。少于这个值大小的请求将不会被压缩，这个值由请求头中的Content-Length字段决定。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gzip_proxied</span><br><span class="line">语法：gzip_proxied [off|expired|no-cache|no-store|private|no_last_modified|no_etag|auth|any] ... </span><br><span class="line">默认值：gzip_proxied off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>根据某些请求和应答来决定是否在对代理请求的应答启用压缩，事实上，代理请求取决于请求头中的“Via”字段，指令中可以同时指定多个不同的参数：</p>
<pre><code>off - 为所有代理请求禁用压缩。
expired - 当“Expires”头禁用缓存时启用压缩。
no-cache - 当“Cache-Control”头设置为no-cache时启用压缩。
no-store - 当“Cache-Control”头设置为no-store时启用压缩。
private - 当“Cache-Control”头设置为private时启用压缩。
no_last_modified - 当“Last-Modified”没有定义时启用压缩。
no_etag - 没有“ETag”头时启用压缩。
auth - 当有一个“Authorization”头时启用压缩。
any - 为所有请求启用压缩。
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gzip_types</span><br><span class="line">gzip_types mime-type [mime-type ...] </span><br><span class="line">默认值：gzip_types text/html </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure>
<p>为除“text/html”之外的MIME类型启用压缩，“text/html”总是会被压缩。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gzip_vary</span><br><span class="line">ggzip_vary on|off </span><br><span class="line">默认值：gzip_vary off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>启用应答头“Vary: Accept-Encoding”，注意，由于一个bug将导致IE 4-6无法缓存内容。</p>
<h4 id="HTTP头处理模块"><a href="#HTTP头处理模块" class="headerlink" title="HTTP头处理模块"></a>HTTP头处理模块</h4><p>这个模块允许设置任意的HTTP头。<br><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_header</span><br><span class="line">语法：add_header name value </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>当服务器应答代码为200, 204, 301, 302或304时为HTTP应答添加头。<br>这个值可以使用变量<br>注意这个指令只会在输出的头部中增加某个新字段，而并不能对某些已经定义的头（如server）进行重写，如果要实现这个操作可以使用第三方模块headers_more。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expires</span><br><span class="line">语法：expires [time|@time-of-day|epoch|max|off] </span><br><span class="line">默认值：expires off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>这个指令控制是否在应答中标记一个过期时间，如果是，如何标记。</p>
<pre><code>off 将禁止修改头部中的 Expires和Cache-Control字段。
epoch 将Expires头设置为1 January, 1970 00:00:01 GMT。
max 将Expires头设置为31 December 2037 23:59:59 GMT，将Cache-Control最大化到10 years。
如果将指令设置为一个不带@标记的值，那么过期时间将是应答时间的相对时间（如果这个时间在“modified”之前），或者是文件的修改时间（当&quot;modified&quot;存在，在版本0.7.0和0.6.32可用），并且可以指定一个负的时间，它将Cache-Control头设置为no-cache比较。
如果指令的值被设置为一个带@标记的值，那么将指定一个绝对的time-of-day过期时间，可以指定两种格式分别为Hh或Hh:Mm，其中H的大小范围为0到24，M的大小范围为0到59（在0.7.9和0.6.34可用）。
一个非负的时间值将Cache-Control头设置为 max-age = #，#将适当的换算为秒数。
</code></pre><p>注意：expires仅仅适用于200, 204, 301, 302,和304应答</p>
<h4 id="默认主页设置模块"><a href="#默认主页设置模块" class="headerlink" title="默认主页设置模块"></a>默认主页设置模块</h4><p>如果URL中没有指定文件，则设置一个默认主页。<br>如下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index index.html;</span><br></pre></td></tr></table></figure></p>
<p>可以指定多个文件，如果第一个文件没有找到，将会查找后面指定的文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index index.html index.htm;</span><br></pre></td></tr></table></figure></p>
<p><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index</span><br><span class="line">语法：index file-path [file-path [ ... ] ]; </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：server, location</span><br></pre></td></tr></table></figure></p>
<h4 id="HTTP-Referer模块"><a href="#HTTP-Referer模块" class="headerlink" title="HTTP Referer模块"></a>HTTP Referer模块</h4><p>当一个请求头的Referer字段中包含一些非正确的字段，这个模块可以禁止这个请求访问站点。<br>这个头可以随意的伪造，因此，使用这个模块并不能100%的阻止这些请求，绝大多数拒绝的请求来自一些典型的浏览器，可以认为这些典型的浏览器并不能提供一个”Referer”头，甚至是那些正确的请求。<br>如下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /photos/ &#123;</span><br><span class="line">  valid_referers none blocked www.mydomain.com mydomain.com;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">$invalid_referer</span>) &#123;</span><br><span class="line">    <span class="built_in">return</span>   403;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">valid_referers</span><br><span class="line">语法：valid_referers [none|blocked|server_names] ... </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：server, location</span><br></pre></td></tr></table></figure></p>
<p>这个指令在referer头的基础上为 $invalid_referer 变量赋值，其值为0或1。<br>可以使用这个指令来实现防盗链功能，如果valid_referers列表中没有Referer头的值， $invalid_referer将被设置为1（参照前例）。</p>
<h4 id="HTTP-Limit-Zone模块"><a href="#HTTP-Limit-Zone模块" class="headerlink" title="HTTP Limit Zone模块"></a>HTTP Limit Zone模块</h4><p>这个模块可以为一个地址指定的会话或者某些特殊情况限制同时连接数，<br>如下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  limit_zone   one  <span class="variable">$binary_remote_addr</span>  10m;</span><br><span class="line"> </span><br><span class="line">  server &#123;</span><br><span class="line">    location /download/ &#123;</span><br><span class="line">      limit_conn   one  1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">limit_zone</span><br><span class="line">语法：limit_zone zone_name <span class="variable">$variable</span> memory_max_size </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：http</span><br></pre></td></tr></table></figure></p>
<p>指令描述会话状态存储区域。<br>会话的数目按照指定的变量来决定，它依赖于使用的变量大小和memory_max_size的值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">limit_conn</span><br><span class="line">语法：limit_conn zone_name max_clients_per_ip </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>指令指定一个会话的最大同时连接数，超过这个数字的请求将被返回”Service unavailable” (503)代码。</p>
<h4 id="HTTP-Limit-Requests模块"><a href="#HTTP-Limit-Requests模块" class="headerlink" title="HTTP Limit Requests模块"></a>HTTP Limit Requests模块</h4><p>这个模块允许为一个指定的会话或者某个特殊情况限制请求数目。<br>示例配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    limit_req_zone  <span class="variable">$binary_remote_addr</span>  zone=one:10m   rate=1r/s;</span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    server &#123;</span><br><span class="line"> </span><br><span class="line">        ...</span><br><span class="line"> </span><br><span class="line">        location /search/ &#123;</span><br><span class="line">            limit_req   zone=one  burst=5;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：limit_req_log_level info|notice|warn|error </span><br><span class="line">默认值：warn </span><br><span class="line">使用字段：http</span><br></pre></td></tr></table></figure></p>
<p>指定记录日志的等级。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：limit_req_zone <span class="variable">$session_variable</span> zone=name_of_zone:size rate=rate </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：http</span><br></pre></td></tr></table></figure></p>
<p>指令描述会话状态存储区域。<br>指令描述会话状态存储的某个区域，会话的值根据给定的变量，如下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone  <span class="variable">$binary_remote_addr</span>  zone=one:10m   rate=1r/s;</span><br></pre></td></tr></table></figure></p>
<p>在这种情况下，将为一个名为“one”的区域分配10MB，这个区域的平均查询速度为每秒最多1个请求。<br>会话将追踪每个用户，但是注意它替换了变量$remote_addr，我们使用的是$binary_remote_addr，减少会话的大小为64字节，一个1MB的区域可以包含大约16000个会话状态。<br>速度可以设置为每秒处理请求数和每分钟处理请求数，其值必须是整数，所以如果你需要指定每秒处理少于1个的请求，2秒处理一个请求，可以使用 “30r/m”。<br>当会话状态储存区域为1M时理论上可以处理32000个会话，每个会话大小为32字节。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法： limit_req zone=zone burst=burst [nodelay] </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>这个指令指定区域（zone）可能的最大请求爆发值(burst),如果其值超过这个数，请求被延时，以便查询按照给定的速度处理。多余的请求将被延迟直到他们的数目小于burst值，在这种情况下，请求将得到”Service unavailable” (503)代码，默认burst的值为0。<br>如下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone  <span class="variable">$binary_remote_addr</span>  zone=one:10m   rate=1r/s;</span><br><span class="line"> </span><br><span class="line">    server &#123;</span><br><span class="line">        location /search/ &#123;</span><br><span class="line">            limit_req   zone=one  burst=5;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>允许一个用户平均每秒处理不超过1个请求，这个区域最多同时处理不超过5个查询，如果在burst值之外的额外请求不可用，可以使用nodelay参数：<br>limit_req   zone=one  burst=5  nodelay;</p>
<h4 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h4><p>控制nginx如何记录请求日志。<br>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log_format gzip <span class="string">'$remote_addr - $remote_user [$time_local]  '</span></span><br><span class="line">                <span class="string">'"$request" $status $bytes_sent '</span></span><br><span class="line">                <span class="string">'"$http_referer" "$http_user_agent" "$gzip_ratio"'</span>;</span><br><span class="line"> </span><br><span class="line">access_log  /spool/logs/nginx-access.log  gzip  buffer=32k;</span><br></pre></td></tr></table></figure></p>
<p>关于记录nginx错误日志请参考HTTP核心模块。<br><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">access_log</span><br><span class="line">语法：access_log path [format [buffer=size | off]] </span><br><span class="line">默认值：access_log <span class="built_in">log</span>/access.log combined </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>参数为连接日志指定了路径，格式和缓冲区大小。使用“off”将在当前的字段中清除access_log的所有参数，如果没有指定日志格式，默认为“combined”。缓冲区大小不能超过写入磁盘文件的最小大小。<br>日志文件路径可以包含变量（0.7.4以上版本），但是有一些限制：</p>
<pre><code>nginx指定的用户必须有创建日志文件的权限。
缓冲区不会工作
每个到来的连接，日志文件将被打开并且在记录日志后迅速关闭，然而，频繁使用的文件描述符将被保存到open_log_file_cache中，关于日志的轮询记录，必须记住随着时间的过去（使用open_log_file_cache的valid参数设置），日志仍然在旧的文件中记录。
</code></pre><p>nginx支持为每个location指定强大的日志记录，同样的连接可以在同一时间输出到不止一个的日志中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_format</span><br><span class="line">语法：log_format name format [format ...] </span><br><span class="line">默认值：log_format combined <span class="string">"..."</span> </span><br><span class="line">使用字段：http server</span><br></pre></td></tr></table></figure></p>
<p>描述记录日志的格式，格式中可以使用大多数变量，也包括一些在写入日志文件过程中定义的变量：</p>
<pre><code>$body_bytes_sent，减去应答头后传送给客户端的字节数，这个变量兼容apache模块mod_log_config的%B参数（在0.3.10前这个变量为$apache_bytes_sent）。
$bytes_sent，传送给客户端的字节数。
$connection，连接数。
$msec，正在写入日志条目的当前时间（精确到百万分之一秒）
$pipe，如果请求为管道的。
$request_length，请求主体的长度。
$request_time，从一个请求发出到而使nginx工作的时间，单位为毫秒（0.5.19版本后可以使用秒为单位）。
$status，应答的状态（代码）。
$time_local，写入普通日志格式的当地时间（服务器时间）。
</code></pre><p>传送到客户端的头中的变量以”sent_http_”标记开头，如：$sent_http_content_range。<br>注意其他模块产生的变量同样可以写入日志，例如你可以记录前端负载均衡应答头使用“upstream_http_”开头的变量，具体请查看负载均衡模块。<br>nginx有一个预定的日志格式称为combined：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_format combined <span class="string">'$remote_addr - $remote_user [$time_local]  '</span></span><br><span class="line">                    <span class="string">'"$request" $status $body_bytes_sent '</span></span><br><span class="line">                    <span class="string">'"$http_referer" "$http_user_agent"'</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open_log_file_cache</span><br><span class="line">语法：open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time] | off </span><br><span class="line">默认值：open_log_file_cache off </span><br><span class="line">使用字段：http server location</span><br></pre></td></tr></table></figure>
<p>这个指令为频繁使用的日志文件描述符所在的路径变量设置缓存。<br>指令选项：</p>
<pre><code>max - 缓存中存储的最大文件描述符数。
inactive - 设置缓存中在某个时间段内没有使用的文件描述符将被移除，默认为10秒。
min_uses - 在一定时间内（inactive指定），一个文件描述符最少使用多少次后被放入缓存，默认为1。
valid - 设置检查同名文件存在的时间，默认是60秒。
off - 关闭缓存。
</code></pre><h4 id="Map模块"><a href="#Map模块" class="headerlink" title="Map模块"></a>Map模块</h4><p>这个模块允许你分类或者同时映射多个值到多个不同值并储存到一个变量中。<br>如下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map  <span class="variable">$http_host</span>  <span class="variable">$name</span>  &#123;</span><br><span class="line">  hostnames;</span><br><span class="line"> </span><br><span class="line">  default          0;</span><br><span class="line"> </span><br><span class="line">  example.com      1;</span><br><span class="line">  *.example.com    1;</span><br><span class="line">  test.com         2;</span><br><span class="line">  *.test.com       2;</span><br><span class="line">  .site.com        3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个典型的使用映射的例子是代替一个含有很多服务器的/location或者重定向：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map <span class="variable">$uri</span> <span class="variable">$new</span> &#123;</span><br><span class="line">  default        http://www.domain.com/home/;</span><br><span class="line"> </span><br><span class="line">  /aa            http://aa.domain.com/;</span><br><span class="line">  /bb            http://bb.domain.com/;</span><br><span class="line">  /john          http://my.domain.com/users/john/;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">server &#123;</span><br><span class="line">  server_name   www.domain.com;</span><br><span class="line">  rewrite  ^    <span class="variable">$new</span>   redirect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map</span><br><span class="line">语法：map <span class="variable">$var1</span> <span class="variable">$var2</span> &#123; ... &#125; </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：http</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map_hash_max_size</span><br><span class="line">语法：map_hash_max_size number </span><br><span class="line">默认值：map_hash_max_size 2048 </span><br><span class="line">使用字段：http</span><br></pre></td></tr></table></figure>
<p>这个指令设置映射表对应的哈希表的最大值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map_hash_bucket_size</span><br><span class="line">语法：map_hash_bucket_size n</span><br><span class="line">默认值：map_hash_bucket_size 32/64/128 </span><br><span class="line">使用字段：http</span><br></pre></td></tr></table></figure></p>
<p>这个指令指定一个映射表中的变量在哈希表中的最大值，这个值取决于处理器的缓存。</p>
<h4 id="Memcached模块"><a href="#Memcached模块" class="headerlink" title="Memcached模块"></a>Memcached模块</h4><p>使用这个模块简单的处理缓存，这个模块将不断的进行完善。<br>示例配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  location / &#123;</span><br><span class="line">    <span class="built_in">set</span> <span class="variable">$memcached_key</span> <span class="variable">$uri</span>;</span><br><span class="line">    memcached_pass     name:11211;</span><br><span class="line">    default_type       text/html;</span><br><span class="line">    error_page         404 = /fallback;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  location = /fallback &#123;</span><br><span class="line">    proxy_pass backend;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">memcached_pass</span><br><span class="line">语法：memcached_pass [ name:port ] </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>后端需要在memcached中设置一些数据，memcached key为“”/uri?args”。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">memcached_connect_timeout</span><br><span class="line">语法：memcached_connect_timeout [ time ] </span><br><span class="line">默认值：60000 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>连接memcached的超时时间，单位为毫秒。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">memcached_read_timeout</span><br><span class="line">语法：memcached_read_timeout [ time ] </span><br><span class="line">默认值：60000 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>读取memcached数据的超时时间，单位为毫秒。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">memcached_send_timeout</span><br><span class="line">语法：memcached_send_timeout [ time ] </span><br><span class="line">默认值：60000 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>发送memcached数据的超时时间，单位为毫秒。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">memcached_buffer_size</span><br><span class="line">语法：memcached_buffer_size [ size ] </span><br><span class="line">默认值：see getpagesize(2) </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>发送/收到的缓冲区大小，单位是字节。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">memcached_next_upstream</span><br><span class="line">语法：memcached_next_upstream [ error | timeout | invalid_response | not_found | off ] </span><br><span class="line">默认值：error timeout </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>指定在哪种错误状态下请求将转发到另外的负载均衡服务器，仅当memcached_pass有两个或两个以上值的时候使用。<br><strong>变量</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$memcached_key</span></span><br><span class="line">memcached key的值</span><br></pre></td></tr></table></figure></p>
<h4 id="HTTP代理模块"><a href="#HTTP代理模块" class="headerlink" title="HTTP代理模块"></a>HTTP代理模块</h4><p>这个模块可以转发请求到其他的服务器。<br>注意当使用http proxy模块（甚至FastCGI），所有的连接请求在发送到后端服务器之前nginx将缓存它们，因此，在测量从后端传送的数据时，它的进度显示可能不正确。<br><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_buffer_size</span><br><span class="line">语法：proxy_buffer_size the_size </span><br><span class="line">默认值：proxy_buffer_size 4k/8k </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>设置从被代理服务器读取的第一部分应答的缓冲区大小。<br>通常情况下这部分应答中包含一个小的应答头。<br>默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_buffering</span><br><span class="line">语法：proxy_buffering on|off </span><br><span class="line">默认值：proxy_buffering on </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>为后端的服务器启用应答缓冲。<br>如果启用缓冲，nginx假设被代理服务器能够非常快的传递应答，并将其放入缓冲区，可以使用 proxy_buffer_size和proxy_buffers设置相关参数。<br>如果响应无法全部放入内存，则将其写入硬盘。<br>如果禁用缓冲，从后端传来的应答将立即被传送到客户端。<br>nginx忽略被代理服务器的应答数目和所有应答的大小，接受proxy_buffer_size所指定的值。<br>对于基于长轮询的Comet应用需要关闭这个指令，否则异步的应答将被缓冲并且Comet无法正常工作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_buffers</span><br><span class="line">语法：proxy_buffers the_number is_size; </span><br><span class="line">默认值：proxy_buffers 8 4k/8k; </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_busy_buffers_size</span><br><span class="line">语法：proxy_busy_buffers_size size; </span><br><span class="line">默认值：proxy_busy_buffers_size [<span class="string">"#proxy buffer size"</span>] * 2; </span><br><span class="line">使用字段：http, server, location, <span class="keyword">if</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache</span><br><span class="line">语法：proxy_cache zone_name; </span><br><span class="line">默认值：None </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure>
<p>设置一个缓存区域的名称，一个相同的区域可以在不同的地方使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_key</span><br><span class="line">语法：proxy_cache_key line; </span><br><span class="line">默认值：<span class="variable">$scheme</span><span class="variable">$proxy_host</span><span class="variable">$request_uri</span>; </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>指令指定了包含在缓存中的缓存关键字。<br>proxy_cache_key “$host$request_uri$cookie_user”;<br>注意默认情况下服务器的主机名并没有包含到缓存关键字中，如果你为你的站点在不同的location中使用二级域，你可能需要在缓存关键字中包换主机名：<br>proxy_cache_key “$scheme$host$request_uri”;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_path</span><br><span class="line">语法：proxy_cache_path path [levels=number] keys_zone=zone_name:zone_size [inactive=time] [max_size=size]; </span><br><span class="line">默认值：None </span><br><span class="line">使用字段：http</span><br></pre></td></tr></table></figure></p>
<p>指令指定缓存的路径和一些其他参数，缓存的数据存储在文件中，并且使用代理url的哈希值作为关键字与文件名。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_methods</span><br><span class="line">语法：proxy_cache_methods [GET HEAD POST]; </span><br><span class="line">默认值：proxy_cache_methods GET HEAD; </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>GET/HEAD用来装饰语句，即你无法禁用GET/HEAD即使你只使用下列语句设置：<br>proxy_cache_methods POST;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_min_uses</span><br><span class="line">语法：proxy_cache_min_uses the_number; </span><br><span class="line">默认值：proxy_cache_min_uses 1; </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>多少次的查询后应答将被缓存，默认1。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_valid</span><br><span class="line">语法：proxy_cache_valid reply_code [reply_code ...] time; </span><br><span class="line">默认值：None </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>为不同的应答设置不同的缓存时间，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_valid  200 302  10m;</span><br><span class="line">proxy_cache_valid  404      1m;</span><br></pre></td></tr></table></figure></p>
<p>为应答代码为200和302的设置缓存时间为10分钟，404代码缓存1分钟。<br>如果只定义时间：<br>proxy_cache_valid 5m;<br>那么只对代码为200, 301和302的应答进行缓存。<br>同样可以使用any参数任何应答。<br>proxy_cache_valid  200 302 10m;<br>proxy_cache_valid  301 1h;<br>proxy_cache_valid  any 1m;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_use_stale</span><br><span class="line">语法：proxy_cache_use_stale [error|timeout|updating|invalid_header|http_500|http_502|http_503|http_504|http_404|off] [...]; </span><br><span class="line">默认值：proxy_cache_use_stale off; </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>这个指令告诉nginx何时从代理缓存中提供一个过期的响应，参数类似于proxy_next_upstream指令。<br>为了防止缓存失效（在多个线程同时更新本地缓存时），你可以指定’updating’参数，它将保证只有一个线程去更新缓存，并且在这个线程更新缓存的过程中其他的线程只会响应当前缓存中的过期版本。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_connect_timeout</span><br><span class="line">语法：proxy_connect_timeout timeout_in_seconds </span><br><span class="line">默认值：proxy_connect_timeout 60 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>指定一个连接到代理服务器的超时时间，需要注意的是这个时间最好不要超过75秒。<br>这个时间并不是指服务器传回页面的时间（这个时间由proxy_read_timeout声明）。如果你的前端代理服务器是正常运行的，但是遇到一些状况（例如没有足够的线程去处理请求，请求将被放在一个连接池中延迟处理），那么这个声明无助于服务器去建立连接。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_headers_hash_bucket_size</span><br><span class="line">语法：proxy_headers_hash_bucket_size size; </span><br><span class="line">默认值：proxy_headers_hash_bucket_size 64; </span><br><span class="line">使用字段：http, server, location, <span class="keyword">if</span></span><br></pre></td></tr></table></figure></p>
<p>设置哈希表中存储的每个数据大小。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_headers_hash_max_size</span><br><span class="line">语法：proxy_headers_hash_max_size size; </span><br><span class="line">默认值：proxy_headers_hash_max_size 512; </span><br><span class="line">使用字段：http, server, location, <span class="keyword">if</span></span><br></pre></td></tr></table></figure></p>
<p>设置哈希表的最大值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy_hide_header</span><br><span class="line">语法：proxy_hide_header the_header </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>nginx不对从被代理服务器传来的”Date”, “Server”, “X-Pad”和”X-Accel-…”应答进行转发，这个参数允许隐藏一些其他的头部字段，但是如果上述提到的头部字段必须被转发，可以使用proxy_pass_header指令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_ignore_client_abort</span><br><span class="line">语法：proxy_ignore_client_abort [ on|off ] </span><br><span class="line">默认值：proxy_ignore_client_abort off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>防止在客户端自己终端请求的情况下中断代理请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_ignore_headers</span><br><span class="line">语法：proxy_ignore_headers name [name ...] </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>这个指令(0.7.54+) 禁止处理来自代理服务器的应答。<br>可以指定的字段为”X-Accel-Redirect”, “X-Accel-Expires”, “Expires”或”Cache-Control”。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_intercept_errors</span><br><span class="line">语法：proxy_intercept_errors [ on|off ] </span><br><span class="line">默认值：proxy_intercept_errors off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>使nginx阻止HTTP应答代码为400或者更高的应答。<br>默认情况下被代理服务器的所有应答都将被传递。<br>如果将其设置为on则nginx会将阻止的这部分代码在一个error_page指令处理，如果在这个error_page中没有匹配的处理方法，则被代理服务器传递的错误应答会按原样传递。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_max_temp_file_size</span><br><span class="line">语法：proxy_max_temp_file_size size; </span><br><span class="line">默认值：proxy_max_temp_file_size 1G; </span><br><span class="line">使用字段：http, server, location, <span class="keyword">if</span></span><br></pre></td></tr></table></figure></p>
<p>当代理缓冲区过大时使用一个临时文件的最大值，如果文件大于这个值，将同步传递请求而不写入磁盘进行缓存。<br>如果这个值设置为零，则禁止使用临时文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_method</span><br><span class="line">语法：proxy_method [method] </span><br><span class="line">默认值：None </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>为后端服务器忽略HTTP请求处理方式，假如你将这个指令指定为POST，那么所有转发到后端的请求都将使用POST请求方式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_next_upstream</span><br><span class="line">语法： proxy_next_upstream [error|timeout|invalid_header|http_500|http_502|http_503|http_504|http_404|off] </span><br><span class="line">默认值：proxy_next_upstream error timeout </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>确定在何种情况下请求将转发到下一个服务器：</p>
<pre><code>error - 在连接到一个服务器，发送一个请求，或者读取应答时发生错误。
timeout - 在连接到服务器，转发请求或者读取应答时发生超时。
invalid_header - 服务器返回空的或者错误的应答。
http_500 - 服务器返回500代码。
http_502 - 服务器返回502代码。
http_503 - 服务器返回503代码。
http_504 - 服务器返回504代码。
http_404 - 服务器返回404代码。
off - 禁止转发请求到下一台服务器。
</code></pre><p>转发请求只发生在没有数据传递到客户端的过程中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_no_cache</span><br><span class="line">语法：proxy_no_cache variable1 variable2 ...; </span><br><span class="line">默认值：None </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>确定在何种情况下缓存的应答将不会使用，示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_no_cache <span class="variable">$cookie_nocache</span>  <span class="variable">$arg_nocache</span><span class="variable">$arg_comment</span>;</span><br><span class="line">proxy_no_cache <span class="variable">$http_pragma</span>     <span class="variable">$http_authorization</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果为空字符串或者等于0，表达式的值等于false。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_pass</span><br><span class="line">语法：proxy_pass URL </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：location, location中的<span class="keyword">if</span>字段</span><br></pre></td></tr></table></figure></p>
<p>这个指令设置被代理服务器的地址和被映射的URI，地址可以使用主机名或IP加端口号的形式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy_pass_header</span><br><span class="line">语法：proxy_pass_header the_name </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>这个指令允许为应答转发一些隐藏的头部字段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_pass_request_headers</span><br><span class="line">语法：proxy_pass_request_headers [ on | off ] ; </span><br><span class="line">默认值：proxy_pass_request_headers on; </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_redirect</span><br><span class="line">语法：proxy_redirect [ default|off|redirect replacement ] </span><br><span class="line">默认值：proxy_redirect default </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure>
<p>如果需要修改从被代理服务器传来的应答头中的”Location”和”Refresh”字段，可以用这个指令设置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_read_timeout</span><br><span class="line">语法：proxy_read_timeout time </span><br><span class="line">默认值：proxy_read_timeout 60 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>决定读取后端服务器应答的超时时间，它决定nginx将等待多久时间来取得一个请求的应答。超时时间是指完成了两次握手后并且状态为established的超时时间。<br>相对于proxy_connect_timeout，这个时间可以扑捉到一台将你的连接放入连接池延迟处理并且没有数据传送的服务器，注意不要将此值设置太低，某些情况下代理服务器将花很长的时间来获得页面应答（例如如当接收一个需要很多计算的报表时），当然你可以在不同的location里面设置不同的值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_redirect_errors</span><br><span class="line">不推荐使用，请使用 proxy_intercept_errors</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_send_lowat</span><br><span class="line">语法：proxy_send_lowat [ on | off ] </span><br><span class="line">默认值：proxy_send_lowat off; </span><br><span class="line">使用字段：http, server, location, <span class="keyword">if</span></span><br></pre></td></tr></table></figure>
<p>设置SO_SNDLOWAT，这个指令仅用于FreeBSD。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_send_timeout</span><br><span class="line">语法：proxy_send_timeout seconds </span><br><span class="line">默认值：proxy_send_timeout 60 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>设置代理服务器转发请求的超时时间，同样指完成两次握手后的时间，如果超过这个时间代理服务器没有数据转发到被代理服务器，nginx将关闭连接。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_body</span><br><span class="line">语法：proxy_set_body [ on | off ] </span><br><span class="line">默认值：proxy_set_body off; </span><br><span class="line">使用字段：http, server, location, <span class="keyword">if</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header</span><br><span class="line">语法：proxy_set_header header value </span><br><span class="line">默认值： Host and Connection</span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure>
<p>这个指令允许将发送到被代理服务器的请求头重新定义或者增加一些字段。<br>这个值可以是一个文本，变量或者它们的组合。<br>proxy_set_header在指定的字段中没有定义时会从它的上级字段继承。<br>默认只有两个字段可以重新定义：<br>proxy_set_header Host $proxy_host;<br>proxy_set_header Connection Close;<br>未修改的请求头“Host”可以用如下方式传送：<br>proxy_set_header Host $http_host;<br>但是如果这个字段在客户端的请求头中不存在，那么不发送数据到被代理服务器。<br>这种情况下最好使用$Host变量，它的值等于请求头中的”Host”字段或服务器名：<br>proxy_set_header Host $host;<br>此外，可以将被代理的端口与服务器名称一起传递：<br>proxy_set_header Host $host:$proxy_port;<br>如果设置为空字符串，则不会传递头部到后端，例如下列设置将禁止后端使用gzip压缩：<br>proxy_set_header  Accept-Encoding  “”;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_store</span><br><span class="line">语法：proxy_store [on | off | path] </span><br><span class="line">默认值：proxy_store off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>这个指令设置哪些传来的文件将被存储，参数”on”保持文件与alias或root指令指定的目录一致，参数”off”将关闭存储，路径名中可以使用变量：<br>proxy_store   /data/www$original_uri;<br>应答头中的”Last-Modified”字段设置了文件最后修改时间，为了文件的安全，可以使用proxy_temp_path指定一个临时文件目录。<br>这个指令为那些不是经常使用的文件做一份本地拷贝。从而减少被代理服务器负载。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">  root                 /data/www;</span><br><span class="line">  error_page           404 = /fetch<span class="variable">$uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /fetch &#123;</span><br><span class="line">  internal;</span><br><span class="line">  proxy_pass           http://backend;</span><br><span class="line">  proxy_store          on;</span><br><span class="line">  proxy_store_access   user:rw  group:rw  all:r;</span><br><span class="line">  proxy_temp_path      /data/temp;</span><br><span class="line">  <span class="built_in">alias</span>                /data/www;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者通过这种方式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">  root                 /data/www;</span><br><span class="line">  error_page           404 = @fetch;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location @fetch &#123;</span><br><span class="line">  internal;</span><br><span class="line"> </span><br><span class="line">  proxy_pass           http://backend;</span><br><span class="line">  proxy_store          on;</span><br><span class="line">  proxy_store_access   user:rw  group:rw  all:r;</span><br><span class="line">  proxy_temp_path      /data/temp;</span><br><span class="line"> </span><br><span class="line">  root                 /data/www;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意proxy_store不是一个缓存，它更像是一个镜像。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_store_access</span><br><span class="line">语法：proxy_store_access users:permissions [users:permission ...] </span><br><span class="line">默认值：proxy_store_access user:rw </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>指定创建文件和目录的相关权限，如：<br>proxy_store_access  user:rw  group:rw  all:r;<br>如果正确指定了组和所有的权限，则没有必要去指定用户的权限：<br>proxy_store_access  group:rw  all:r;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_temp_file_write_size</span><br><span class="line">语法：proxy_temp_file_write_size size; </span><br><span class="line">默认值：proxy_temp_file_write_size [<span class="string">"#proxy buffer size"</span>] * 2; </span><br><span class="line">使用字段：http, server, location, <span class="keyword">if</span></span><br></pre></td></tr></table></figure></p>
<p>设置在写入proxy_temp_path时数据的大小，在预防一个工作进程在传递文件时阻塞太长。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_temp_path</span><br><span class="line">语法：proxy_temp_path dir-path [ level1 [ level2 [ level3 ] ; </span><br><span class="line">默认值：在configure时由--http-proxy-temp-path指定 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>类似于http核心模块中的client_body_temp_path指令，指定一个地址来缓冲比较大的被代理请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_upstream_fail_timeout</span><br><span class="line">0.5.0版本后不推荐使用，请使用http负载均衡模块中server指令的fail_timeout参数。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_upstream_fail_timeout</span><br><span class="line">0.5.0版本后不推荐使用，请使用http负载均衡模块中server指令的max_fails参数。</span><br></pre></td></tr></table></figure>
<p><strong>变量</strong><br>该模块中包含一些内置变量，可以用于proxy_set_header指令中以创建头部。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$proxy_host</span></span><br><span class="line">被代理服务器的主机名。</span><br><span class="line"><span class="variable">$proxy_host</span></span><br><span class="line">被代理服务器的端口号。</span><br><span class="line"><span class="variable">$proxy_add_x_forwarded_for</span></span><br><span class="line">包含客户端请求头中的<span class="string">"X-Forwarded-For"</span>，与<span class="variable">$remote_addr</span>用逗号分开，如果没有<span class="string">"X-Forwarded-For"</span>请求头，则<span class="variable">$proxy_add_x_forwarded_for</span>等于<span class="variable">$remote_addr</span>。</span><br></pre></td></tr></table></figure></p>
<h4 id="URL重写模块"><a href="#URL重写模块" class="headerlink" title="URL重写模块"></a>URL重写模块</h4><p>这个模块允许使用正则表达式重写URI（需PCRE库），并且可以根据相关变量重定向和选择不同的配置。<br>如果这个指令在server字段中指定，那么将在被请求的location确定之前执行，如果在指令执行后所选择的location中有其他的重写规则，那么它们也被执行。如果在location中执行这个指令产生了新的URI，那么location又一次确定了新的URI。<br>这样的循环可以最多执行10次，超过以后nginx将返回500错误。<br><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span></span><br><span class="line">语法：<span class="built_in">break</span></span><br><span class="line">默认值：none</span><br><span class="line">使用字段：server, location, <span class="keyword">if</span></span><br></pre></td></tr></table></figure></p>
<p>完成当前设置的规则，停止执行其他的重写指令。<br>示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$slow</span>) &#123;</span><br><span class="line">  limit_rate  10k;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span></span><br><span class="line">语法：<span class="keyword">if</span> (condition) &#123; ... &#125; </span><br><span class="line">默认值：none</span><br><span class="line">使用字段：server, location</span><br></pre></td></tr></table></figure>
<p>判断一个条件，如果条件成立，则后面的大括号内的语句将执行，相关配置从上级继承。<br>可以在判断语句中指定下列值：</p>
<pre><code>一个变量的名称；不成立的值为：空字符传&quot;&quot;或者一些用“0”开始的字符串。
一个使用=或者!=运算符的比较语句。
使用符号~*和~模式匹配的正则表达式：
~为区分大小写的匹配。
~*不区分大小写的匹配（firefox匹配FireFox）。
!~和!~*意为“不匹配的”。
使用-f和!-f检查一个文件是否存在。
使用-d和!-d检查一个目录是否存在。
使用-e和!-e检查一个文件，目录或者软链接是否存在。 
使用-x和!-x检查一个文件是否为可执行文件。 
</code></pre><p>正则表达式的一部分可以用圆括号，方便之后按照顺序用$1-$9来引用。<br>示例配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$http_user_agent</span> ~ MSIE) &#123;</span><br><span class="line">  rewrite  ^(.*)$  /msie/<span class="variable">$1</span>  <span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$http_cookie</span> ~* <span class="string">"id=([^;] +)(?:;|$)"</span> ) &#123;</span><br><span class="line">  <span class="built_in">set</span>  <span class="variable">$id</span>  <span class="variable">$1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$request_method</span> = POST ) &#123;</span><br><span class="line">  <span class="built_in">return</span> 405;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!-f <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  proxy_pass  http://127.0.0.1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$slow</span>) &#123;</span><br><span class="line">  limit_rate  10k;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$invalid_referer</span>) &#123;</span><br><span class="line">  <span class="built_in">return</span>   403;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$args</span> ~ post=140)&#123;</span><br><span class="line">  rewrite ^ http://example.com/ permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>内置变量$invalid_referer用指令valid_referers指定。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">return</span></span><br><span class="line">语法：<span class="built_in">return</span> code </span><br><span class="line">默认值：none</span><br><span class="line">使用字段：server, location, <span class="keyword">if</span></span><br></pre></td></tr></table></figure></p>
<p>这个指令结束执行配置语句并为客户端返回状态代码，可以使用下列的值：204，400，402-406，408，410, 411, 413, 416与500-504。此外，非标准代码444将关闭连接并且不发送任何的头部。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rewrite</span><br><span class="line">语法：rewrite regex replacement flag </span><br><span class="line">默认值：none</span><br><span class="line">使用字段：server, location, <span class="keyword">if</span></span><br></pre></td></tr></table></figure></p>
<p>按照相关的正则表达式与字符串修改URI，指令按照在配置文件中出现的顺序执行。<br>注意重写规则只匹配相对路径而不是绝对的URL，如果想匹配主机名，可以加一个if判断，如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$host</span> ~* www\.(.*)) &#123;</span><br><span class="line">  <span class="built_in">set</span> <span class="variable">$host_without_www</span> <span class="variable">$1</span>;</span><br><span class="line">  rewrite ^(.*)$ http://<span class="variable">$host_without_www</span><span class="variable">$1</span> permanent; <span class="comment"># $1为'/foo'，而不是'www.mydomain.com/foo'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以在重写指令后面添加标记。<br>如果替换的字符串以http://开头，请求将被重定向，并且不再执行多余的rewrite指令。<br>标记可以是以下的值：</p>
<pre><code>last - 完成重写指令，之后搜索相应的URI或location。
break - 完成重写指令。
redirect - 返回302临时重定向，如果替换字段用http://开头则被使用。
permanent - 返回301永久重定向。
</code></pre><p>注意如果一个重定向是相对的（没有主机名部分），nginx将在重定向的过程中使用匹配server_name指令的“Host”头或者server_name指令指定的第一个名称，如果头不匹配或不存在，如果没有设置server_name，将使用本地主机名，如果你总是想让nginx使用“Host”头，可以在server_name使用“*”通配符（查看http核心模块中的server_name）。例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rewrite  ^(/download/.*)/media/(.*)\..*$  <span class="variable">$1</span>/mp3/<span class="variable">$2</span>.mp3  last;</span><br><span class="line">rewrite  ^(/download/.*)/audio/(.*)\..*$  <span class="variable">$1</span>/mp3/<span class="variable">$2</span>.ra   last;</span><br><span class="line"><span class="built_in">return</span>   403;</span><br></pre></td></tr></table></figure></p>
<p>但是如果我们将其放入一个名为/download/的location中，则需要将last标记改为break，否则nginx将执行10次循环并返回500错误。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location /download/ &#123;</span><br><span class="line">  rewrite  ^(/download/.*)/media/(.*)\..*$  <span class="variable">$1</span>/mp3/<span class="variable">$2</span>.mp3  <span class="built_in">break</span>;</span><br><span class="line">  rewrite  ^(/download/.*)/audio/(.*)\..*$  <span class="variable">$1</span>/mp3/<span class="variable">$2</span>.ra   <span class="built_in">break</span>;</span><br><span class="line">  <span class="built_in">return</span>   403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果替换字段中包含参数，那么其余的请求参数将附加到后面，为了防止附加，可以在最后一个字符后面跟一个问号：<br>rewrite  ^/users/(.*)$  /show?user=$1?  last;<br>注意：大括号（{和}），可以同时用在正则表达式和配置块中，为了防止冲突，正则表达式使用大括号需要用双引号（或者单引号）。例如要重写以下的URL：<br>/photos/123456<br>为:<br>/path/to/photos/12/1234/123456.png<br>则使用以下正则表达式（注意引号）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite  <span class="string">"/photos/([0-9] &#123;2&#125;)([0-9] &#123;2&#125;)([0-9] &#123;2&#125;)"</span> /path/to/photos/<span class="variable">$1</span>/<span class="variable">$1</span><span class="variable">$2</span>/<span class="variable">$1</span><span class="variable">$2</span><span class="variable">$3</span>.png;</span><br></pre></td></tr></table></figure></p>
<p>同样，重写只对路径进行操作，而不是参数，如果要重写一个带参数的URL，可以使用以下代替：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$args</span> ^~ post=100)&#123;</span><br><span class="line">  rewrite ^ http://example.com/new-address.html? permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意$args变量不会被编译，与location过程中的URI不同（参考http核心模块中的location）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span></span><br><span class="line">语法：<span class="built_in">set</span> variable value </span><br><span class="line">默认值：none</span><br><span class="line">使用字段：server, location, <span class="keyword">if</span></span><br></pre></td></tr></table></figure></p>
<p>指令设置一个变量并为其赋值，其值可以是文本，变量和它们的组合。<br>你可以使用set定义一个新的变量，但是不能使用set设置$http_xxx头部变量的值。具体可以查看这个例子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uninitialized_variable_warn</span><br><span class="line">语法：uninitialized_variable_warn on|off </span><br><span class="line">默认值：uninitialized_variable_warn on </span><br><span class="line">使用字段：http, server, location, <span class="keyword">if</span></span><br></pre></td></tr></table></figure></p>
<p>开启或关闭在未初始化变量中记录警告日志。<br>事实上，rewrite指令在配置文件加载时已经编译到内部代码中，在解释器产生请求时使用。<br>这个解释器是一个简单的堆栈虚拟机，如下列指令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /download/ &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">$forbidden</span>) &#123;</span><br><span class="line">    <span class="built_in">return</span>   403;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">$slow</span>) &#123;</span><br><span class="line">    limit_rate  10k;</span><br><span class="line">  &#125;</span><br><span class="line">  rewrite  ^/(download/.*)/media/(.*)\..*$  /<span class="variable">$1</span>/mp3/<span class="variable">$2</span>.mp3  <span class="built_in">break</span>;</span><br></pre></td></tr></table></figure></p>
<p>将被编译成以下顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">variable $forbidden</span><br><span class="line">checking to zero</span><br><span class="line">recovery 403</span><br><span class="line">completion of entire code</span><br><span class="line">variable $slow</span><br><span class="line">checking to zero</span><br><span class="line">checkings of regular expression</span><br><span class="line">copying &quot;/&quot;</span><br><span class="line">copying $1</span><br><span class="line">copying &quot;/mp3/&quot;</span><br><span class="line">copying $2</span><br><span class="line">copying &quot;..mpe&quot;</span><br><span class="line">completion of regular expression</span><br><span class="line">completion of entire sequence</span><br></pre></td></tr></table></figure></p>
<p>注意并没有关于limit_rate的代码，因为它没有提及ngx_http_rewrite_module模块，“if”块可以类似”location”指令在配置文件的相同部分同时存在。<br>如果$slow为真，对应的if块将生效，在这个配置中limit_rate的值为10k。<br>指令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite  ^/(download/.*)/media/(.*)\..*$  /<span class="variable">$1</span>/mp3/<span class="variable">$2</span>.mp3  <span class="built_in">break</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果我们将第一个斜杠括入圆括号，则可以减少执行顺序：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite  ^(/download/.*)/media/(.*)\..*$  <span class="variable">$1</span>/mp3/<span class="variable">$2</span>.mp3  <span class="built_in">break</span>;</span><br></pre></td></tr></table></figure></p>
<p>之后的顺序类似如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">checking regular expression</span><br><span class="line">copying $1</span><br><span class="line">copying &quot;/mp3/&quot;</span><br><span class="line">copying $2</span><br><span class="line">copying &quot;..mpe&quot;</span><br><span class="line">completion of regular expression</span><br><span class="line">completion of entire code</span><br></pre></td></tr></table></figure></p>
<h4 id="SSI模块"><a href="#SSI模块" class="headerlink" title="SSI模块"></a>SSI模块</h4><p>这个模块为处理服务器端包含（SSI）的输入提供一个过滤器，目前所支持的SSI命令并不完善。<br>如下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  ssi  on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssi</span><br><span class="line">语法：ssi [ on | off ] </span><br><span class="line">默认值：ssi off </span><br><span class="line">使用字段：http, server, location, location中的<span class="keyword">if</span>字段</span><br></pre></td></tr></table></figure></p>
<p>启用SSI处理。<br>注意如果启用SSI，那么Last-Modified头和Content-Length头不会传递。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssi_silent_errors</span><br><span class="line">语法：ssi_silent_errors [on|off] </span><br><span class="line">默认值：ssi_silent_errors off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>如果在处理SSI的过程中出现“[an error occurred while processing the directive]”错误，禁止将其输出。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssi_types</span><br><span class="line">语法：ssi_types mime-type [mime-type ...] </span><br><span class="line">默认值：ssi_types text/html </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>默认只解析text/html类型，这个参数可以指定其他的MIME类型。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssi_value_length</span><br><span class="line">语法：ssi_value_length length </span><br><span class="line">默认值：ssi_value_length 256 </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>定义允许SSI使用的参数值的长度。</p>
<p>SSI 命令<br>命令格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--#  command parameter1=value parameter2=value... --&gt;</span><br></pre></td></tr></table></figure></p>
<p>因为功能支持问题，暂不作详细的说明。</p>
<p><strong>变量</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$date_local</span></span><br><span class="line">本地时区的当前时间，选项 <span class="string">"timefmt"</span>可以指定格式。</span><br><span class="line"><span class="variable">$date_gmt</span></span><br><span class="line">当前的格林尼治时间，选项 <span class="string">"timefmt"</span>可以指定格式。</span><br></pre></td></tr></table></figure></p>
<h4 id="User-ID模块"><a href="#User-ID模块" class="headerlink" title="User ID模块"></a>User ID模块</h4><p>模块ngx_http_userid_module为连接发布cookie，主要使用$uid_got和$uid_set变量，注意：$uid_got无法$uid_set在SSI中取得，因为SSI过滤模块工作在userid模块过滤之前。<br>这个模块相当于Apache的mod_uid模块。<br>示例配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">userid          on;</span><br><span class="line">userid_name     uid;</span><br><span class="line">userid_domain   example.com;</span><br><span class="line">userid_path     /;</span><br><span class="line">userid_expires  365d;</span><br><span class="line">userid_p3p      <span class="string">'policyref="/w3c/p3p.xml", CP="CUR ADM OUR NOR STA NID"'</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userid</span><br><span class="line">语法：userid [on|v1|<span class="built_in">log</span>||off] </span><br><span class="line">默认值：userid off </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>是否启用发出cookie或者记录到被请求的cookie：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">on - 启用版本2的cookie并记录。</span><br><span class="line">v1 - 启用版本1的cookie并记录。</span><br><span class="line">log - 不传送cookie，但是写入日志。</span><br><span class="line">off - 禁用cookie。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userid_domain</span><br><span class="line">语法：userid_domain [ name | none ] </span><br><span class="line">默认值：userid_domain none </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure>
<p>指定cookie的域名，参数“none”不对任何域名发出cookie。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userid_expires</span><br><span class="line">语法：userid_expires [ time | max ] </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>设置cookie的过期时间。<br>参数设置并发出浏览器对于cookie的实效时间，值“max”指定过期时间为：2037年12月31日23:55:55 GMT，这是某些旧浏览器所能识别的最大时间。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userid_name</span><br><span class="line">语法：userid_name name </span><br><span class="line">默认值：userid_name uid </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>设置cookie的名称。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userid_p3p</span><br><span class="line">语法：userid_p3p line </span><br><span class="line">默认值：none </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>为和cookie一起传递的P3P头指定一个值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userid_path</span><br><span class="line">语法：userid_path path </span><br><span class="line">默认值：userid_path / </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>设置cookie路径。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userid_service</span><br><span class="line">语法：userid_service number </span><br><span class="line">默认值：userid_service address </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>设置cookie发布的服务器地址，如果不设置，版本一的cookie将其设置为0，版本二将其设置为服务器IP。</p>
<h4 id="uWSGI模块"><a href="#uWSGI模块" class="headerlink" title="uWSGI模块"></a>uWSGI模块</h4><p>为uwsgi协议提供支持。<br>示例配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    uwsgi_pass unix:///var/run/example.com.sock;</span><br><span class="line">    include uwsgi_params;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>注意不要把uwsgi协议和uWSGI服务器混淆。<br><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uwsgi_pass</span><br><span class="line">语法：uwsgi_pass uri</span><br><span class="line">默认值：none </span><br><span class="line">使用字段：server, location</span><br></pre></td></tr></table></figure></p>
<p>为一个uwsgi兼容服务器设置监听地址（tcp套接字，unix套接字或者流块）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uwsgi_param</span><br><span class="line">语法：uwsgi_param key value</span><br><span class="line">默认值：none </span><br><span class="line">使用字段：server, location</span><br></pre></td></tr></table></figure></p>
<p>为一个uwsgi请求增加一对key/value值。<br>示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    uwsgi_pass unix:///var/run/example.com.sock;</span><br><span class="line">    include uwsgi_params;</span><br><span class="line">    uwsgi_param NEW_VAR foo;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uwsgi_modifier1</span><br><span class="line">语法：uwsgi_modifier1 value </span><br><span class="line">默认值：0 </span><br><span class="line">使用字段：server, location</span><br></pre></td></tr></table></figure>
<p>为一个uwsgi请求设置第一个修饰语（默认为一个WSGI请求）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uwsgi_modifier2</span><br><span class="line">语法：uwsgi_modifier2 value </span><br><span class="line">默认值：0 </span><br><span class="line">使用字段：server, location</span><br></pre></td></tr></table></figure></p>
<p>为一个uwsgi请求设置第二个修饰语。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uwsgi_string</span><br><span class="line">语法：uwsgi_string string </span><br><span class="line">默认值： none </span><br><span class="line">使用字段：server, location</span><br></pre></td></tr></table></figure></p>
<p>为一个uwsgi请求增加一个字符串。<br>示例（为一个支持eval修饰语的uwsgi兼容服务器）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    uwsgi_pass unix:///var/run/example.com.sock;</span><br><span class="line">    uwsgi_pass_request_headers off;</span><br><span class="line">    uwsgi_pass_request_body off;</span><br><span class="line">    uwsgi_string <span class="string">"</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">import uwsgi </span></span><br><span class="line"><span class="string">uwsgi.start_response('200 OK', [('Content-type','text/plain')])</span></span><br><span class="line"><span class="string">total = 30+22</span></span><br><span class="line"><span class="string">uwsgi.send("</span>30 + 22 = %d<span class="string">" % total)</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">"</span>;</span><br><span class="line"> </span><br><span class="line">    uwsgi_modifier1 22;</span><br><span class="line">    uwsgi_modifier2 0;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uwsgi_pass_request_headers</span><br><span class="line">语法：uwsgi_pass_request_headers on/off </span><br><span class="line">默认值：on </span><br><span class="line">使用字段：server, location</span><br></pre></td></tr></table></figure>
<p>在uwsgi请求中传递HTTP请求头。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uwsgi_pass_request_body</span><br><span class="line">语法：uwsgi_pass_request_body on/off </span><br><span class="line">默认值：on </span><br><span class="line">使用字段：server, location</span><br></pre></td></tr></table></figure></p>
<p>在uwsgi请求中传递HTTP请求实体（如果其可用）。</p>
<h4 id="SplitClients模块"><a href="#SplitClients模块" class="headerlink" title="SplitClients模块"></a>SplitClients模块</h4><p>ngx-http-split-clients模块基于一些特定条件分开客户端连接，(例如ip地址,请求头,cookies等)<br>示例配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    split-clients <span class="string">"<span class="variable">$&#123;remote-addr&#125;</span>AAA"</span> <span class="variable">$variant</span> &#123;</span><br><span class="line">        0.5% .one;</span><br><span class="line">        2.0% .two;</span><br><span class="line">        - <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    server &#123;</span><br><span class="line">        location / &#123;</span><br><span class="line">             index index<span class="variable">$&#123;variant&#125;</span>.html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以使用$cookie-…作为来源来分离请求，来源字符串使用CRC32进行哈希计算并且哈希百分比将作为来源的值。<br><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">split-clients</span><br><span class="line">语法：split-clients <span class="variable">$variable</span> &#123; ... &#125; </span><br><span class="line">默认值：none</span><br><span class="line">使用字段：http</span><br></pre></td></tr></table></figure></p>
<h3 id="可选HTTP模块"><a href="#可选HTTP模块" class="headerlink" title="可选HTTP模块"></a>可选HTTP模块</h3><h4 id="HTTP-Addition模块"><a href="#HTTP-Addition模块" class="headerlink" title="HTTP Addition模块"></a>HTTP Addition模块</h4><p>这个模块可以在当前的location之前或者之后增加别的location。<br>它作为一个输出过滤器执行，包含到其他location中的主请求和子请求不会被完全缓冲，并且仍然以流的形式传递到客户端，因为最终应答体的长度在传递HTTP头的时候是未知的，HTTP的chunked编码总是在这里使用。<br>默认情况下这个模块是没有编译的，如果要使用则需要在编译时指定下列参数：<br>./configure –with-http_addition_module<br>示例配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  add_before_body   /before_action;</span><br><span class="line">  add_after_body    /after_action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_before_body</span><br><span class="line">语法：add_before_body uri </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>在应答体的前面增加URI，为一个处理结果发出子请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_after_body</span><br><span class="line">语法：add_after_body uri </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<p>在应答体的后面增加URI，为一个处理结果发出子请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addition_types</span><br><span class="line">语法：addition_types mime-type [mime-type ...] </span><br><span class="line">默认值：text/html </span><br><span class="line">使用字段：http, server, location</span><br></pre></td></tr></table></figure></p>
<h3 id="邮件模块"><a href="#邮件模块" class="headerlink" title="邮件模块"></a>邮件模块</h3><h4 id="邮件核心模块"><a href="#邮件核心模块" class="headerlink" title="邮件核心模块"></a>邮件核心模块</h4><p>邮件代理配置<br>nginx可以处理和代理以下的邮件协议：</p>
<pre><code>IMAP 
POP3 
SMTP
</code></pre><p><strong>认证</strong><br>nginx使用外部的HTTP类服务器来了解它将连接到哪个后端的IMAP/POP。<br>nginx在HTTP头中通过认证信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /auth HTTP/1.0</span><br><span class="line">Host: auth.server.hostname</span><br><span class="line">Auth-Method: plain</span><br><span class="line">Auth-User: user</span><br><span class="line">Auth-Pass: password</span><br><span class="line">Auth-Protocol: imap</span><br><span class="line">Auth-Login-Attempt: 1</span><br><span class="line">Client-IP: 192.168.1.1</span><br></pre></td></tr></table></figure></p>
<p>合适的应答为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK      <span class="comment"># 这个字段实际上是被忽略或者可能不存在。</span></span><br><span class="line">Auth-Status: OK</span><br><span class="line">Auth-Server: 192.168.1.10</span><br><span class="line">Auth-Port: 110</span><br><span class="line">Auth-User: newname   <span class="comment"># 如果你连接到一个后端可以不理会这个用户名。</span></span><br></pre></td></tr></table></figure></p>
<p>当为POP3认证使用APOP时，你必须返回Auth-Pass：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK      <span class="comment"># 这个字段实际上是被忽略或者可能不存在。</span></span><br><span class="line">Auth-Status: OK</span><br><span class="line">Auth-Server: 192.168.1.10</span><br><span class="line">Auth-Port: 110</span><br><span class="line">Auth-User: newname   <span class="comment"># 如果你连接到一个后端可以不理会这个用户名。</span></span><br><span class="line">Auth-Pass: password  <span class="comment"># 这里必须为明文的用户名密码。</span></span><br></pre></td></tr></table></figure></p>
<p>失败的应答为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK      <span class="comment"># 这个字段实际上是被忽略或者可能不存在。</span></span><br><span class="line">Auth-Status: Invalid login or password</span><br><span class="line">Auth-Wait: 3         <span class="comment"># nginx将在3秒后重新读取客户端的用户名与密码。</span></span><br></pre></td></tr></table></figure></p>
<p><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">imap_capabilities</span><br><span class="line">语法：imap_capabilities <span class="string">"capability1"</span> [<span class="string">"capability2"</span> .. <span class="string">"capabilityN"</span>] </span><br><span class="line">默认值：<span class="string">"IMAP4"</span> <span class="string">"IMAP4rev1"</span> <span class="string">"UIDPLUS"</span> </span><br><span class="line">使用字段：main, server</span><br></pre></td></tr></table></figure></p>
<p>在客户端发布IMAP命令CAPABILITY时，设置IMAP协议扩展列表，STARTTLS在你使用starttls指令时会自动添加。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">imap_client_buffer</span><br><span class="line">语法：imap_client_buffer size </span><br><span class="line">默认值：4K/8K</span><br><span class="line">使用字段：main, server</span><br></pre></td></tr></table></figure></p>
<p>为IMAP命令设置读取缓冲区大小，默认值为分页大小（根据系统不同为4k或8k）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listen</span><br><span class="line">语法：listen address:port [ <span class="built_in">bind</span> ] </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：server</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">listen指令指定了server&#123;...&#125;字段中可以被访问到的ip地址及端口号，可以只指定一个ip，一个端口，或者一个可解析的服务器名。</span><br><span class="line">listen 127.0.0.1:8000;</span><br><span class="line">listen 127.0.0.1;</span><br><span class="line">listen 8000;</span><br><span class="line">listen *:8000;</span><br><span class="line">listen localhost:8000;</span><br><span class="line">ipv6地址格式（0.7.58）在一个方括号中指定：</span><br><span class="line">listen [::]:8000;</span><br><span class="line">listen [fe80::1];</span><br><span class="line">指令中可以指出系统调用bind(2)。</span><br><span class="line">bind -- 指出必须为这个“地址：端口”对独立构建bind(2)，如果多个指令监听同一端口但是不同的地址和某个listen指令为这个端口（*:port）监听所有地址，那么nginx仅构建bind(2)到*:port，在这种情况下地址通过系统调用getsockname()取得。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pop3_auth</span><br><span class="line">语法：pop3_auth [plain] [apop] [cram-md5] </span><br><span class="line">默认值：plain </span><br><span class="line">使用字段：main, server</span><br></pre></td></tr></table></figure>
<p>为POP3客户端设置允许的认证动作：<br>·plain - USER/PASS,AUTH PLAIN,AUTH LOGIN<br>·apop - APOP<br>·cram-md5 - AUTH CRAM-MD5<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pop3_capabilities</span><br><span class="line">语法：pop3_capabilities <span class="string">"capability1"</span> [<span class="string">"capability2"</span> .. <span class="string">"capabilityN"</span>] </span><br><span class="line">默认值：<span class="string">"TOP"</span> <span class="string">"USER"</span> <span class="string">"UIDL"</span> </span><br><span class="line">使用字段：main, server</span><br></pre></td></tr></table></figure></p>
<p>在客户端发布POP3命令CAPA时，设置POP3协议扩展列表，STLS在你使用starttls指令时会自动添加，SASL通过指令pop3_auth添加。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol</span><br><span class="line">语法：protocol [ pop3 | imap | smtp ] ; </span><br><span class="line">默认值：IMAP </span><br><span class="line">使用字段：server</span><br></pre></td></tr></table></figure></p>
<p>为这个server块设置邮件协议。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">语法：server &#123;...&#125; </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：mail</span><br></pre></td></tr></table></figure></p>
<p>指定一个虚拟服务器配置。<br>没有明确的机制来分开基于域名（请求中的主机头）和基于IP的虚拟主机。<br>可以通过listen指令来指定必须连接到这个server块的所有地址和端口，并且在server_name指令中可以指定所有的域名。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server_name</span><br><span class="line">语法：server_name name fqdn_server_host </span><br><span class="line">默认值：主机名，通过调用gethostname()取得。 </span><br><span class="line">使用字段：mail, server</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">smtp_auth</span><br><span class="line">语法：smtp_auth [login] [plain] [cram-md5] ; </span><br><span class="line">默认值：login plain </span><br><span class="line">使用字段：main, server</span><br></pre></td></tr></table></figure>
<p>为SMTP客户端设置允许的认证动作：</p>
<pre><code>login - AUTH LOGIN
plain - AUTH PLAIN
cram-md5 - AUTH CRAM-MD5
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">smtp_capabilities</span><br><span class="line">语法：smtp_capabilities “capability1” [“capability2” .. “capabilityN”] </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：main, server</span><br></pre></td></tr></table></figure>
<p>在客户端发布命令EHLO时，设置SMTP协议扩展列表，这个列表使用smtp_auth指令中启用的动作自动扩展。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">so_keepalive</span><br><span class="line">语法：so_keepalive on|off; </span><br><span class="line">默认值：off </span><br><span class="line">使用字段：main, server</span><br></pre></td></tr></table></figure></p>
<p>为后端的IMAP/POP3设置socket SO_KEEPALIVE选项。FreeBSD中keepalive参数使用于所有的连接，并且可以通过内核参数（sysctl net.inet.tcp.always_keepalive）关闭。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timeout</span><br><span class="line">语法：timeout milliseconds; </span><br><span class="line">默认值：60000 </span><br><span class="line">使用字段：main, server</span><br></pre></td></tr></table></figure></p>
<p>设置到后端代理连接的超时时间。</p>
<h4 id="邮件认证模块"><a href="#邮件认证模块" class="headerlink" title="邮件认证模块"></a>邮件认证模块</h4><p>示例配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auth_http           localhost:9000/cgi-bin/nginxauth.cgi;</span><br><span class="line">auth_http_timeout   5;</span><br></pre></td></tr></table></figure></p>
<p><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auth_http</span><br><span class="line">语法：auth_http URL </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：mail, server</span><br></pre></td></tr></table></figure></p>
<p>为认证设置网址到扩展HTTP类服务器。到达的协议请查看邮件核心模块中的pop3_auth指令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auth_http_header</span><br><span class="line">语法：auth_http_header header value </span><br><span class="line">默认值：no </span><br><span class="line">使用字段：mail, server</span><br></pre></td></tr></table></figure></p>
<p>在认证过程中增加一个HTTP头和它的值，可以使用一个共享的秘密短语确保请求总是通过nginx应答。如：<br>auth_http_header X-NGX-Auth-Key “secret_string”;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auth_http_timeout</span><br><span class="line">语法：auth_http_timeout milliseconds; </span><br><span class="line">默认值：60000 </span><br><span class="line">使用字段：mail, server</span><br></pre></td></tr></table></figure></p>
<p>为认证进程设置超时时间。</p>
<h4 id="邮件代理模块"><a href="#邮件代理模块" class="headerlink" title="邮件代理模块"></a>邮件代理模块</h4><p>nginx可以代理IMAP, POP3,和SMTP协议。<br><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy</span><br><span class="line">语法：proxy on | off </span><br><span class="line">默认值：off </span><br><span class="line">使用字段：mail, server</span><br></pre></td></tr></table></figure></p>
<p>设置是否启用邮件代理。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_buffer</span><br><span class="line">语法：proxy_buffer size </span><br><span class="line">默认值：4K/8K </span><br><span class="line">使用字段：mail, server</span><br></pre></td></tr></table></figure></p>
<p>为代理连接设置缓冲区大小，默认为分页大小，根据不同的操作系统可能是4k或8k。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_pass_error_message</span><br><span class="line">语法：proxy_pass_error_message on | off </span><br><span class="line">默认值：off </span><br><span class="line">使用字段：mail, server</span><br></pre></td></tr></table></figure></p>
<p>可以把从后端获取的错误认证信息传递到客户端，通常如果通过了nginx的认证，那么后端的错误信息无法传递到客户端。<br>但是一些正确密码应答中的POP3错误，如CommuniGatePro通知用户一个关于邮箱超出容量限制（或者其它事件）将在认证中周期性的发出错误，在这种情况下有必要打开proxy_error_message。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_timeout</span><br><span class="line">语法：proxy_timeout time </span><br><span class="line">默认值：24h </span><br><span class="line">使用字段：mail, server</span><br></pre></td></tr></table></figure></p>
<p>为代理连接设置超时时间。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xclient</span><br><span class="line">语法：xclient on | off </span><br><span class="line">默认值：on </span><br><span class="line">使用字段：mail, server</span><br></pre></td></tr></table></figure></p>
<p>是否为SMTP后端连接启用XCLIENT命令，这将允许后端强制客户端连接建立在IP/HELO/LOGIN上。<br>如果xclient启用，那么nginx首先转发到后端：<br>EHLO server_name<br>然后：<br>XCLIENT PROTO=ESMTP HELO=client_helo ADDR=client_ip LOGIN=authentificated_user NAME=[UNAVAILABLE]</p>
<h4 id="邮件SSL认证模块"><a href="#邮件SSL认证模块" class="headerlink" title="邮件SSL认证模块"></a>邮件SSL认证模块</h4><p>这个模块为POP3/IMAP/SMTP提供SSL/TLS支持。配置与HTTP SSL模块基本相同，但是不支持检察客户端证书。<br><strong>指令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssl</span><br><span class="line">语法：ssl on | off </span><br><span class="line">默认值：ssl off </span><br><span class="line">使用字段：mail, server</span><br></pre></td></tr></table></figure></p>
<p>为这个虚拟主机启用SSL。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssl_certificate</span><br><span class="line">语法：ssl_certificate file </span><br><span class="line">默认值：cert.pem </span><br><span class="line">使用字段：mail, server</span><br></pre></td></tr></table></figure></p>
<p>为这个虚拟主机指定PEM格式的证书文件，相同的文件可以包含其它的证书，同样密钥为PEM格式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssl_certificate_key</span><br><span class="line">语法：ssl_certificate_key file </span><br><span class="line">默认值：cert.pem </span><br><span class="line">使用字段：mail, server</span><br></pre></td></tr></table></figure></p>
<p>为这个虚拟主机指定PEM格式的密钥。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssl_ciphers</span><br><span class="line">语法：ssl_ciphers file ciphers </span><br><span class="line">默认值：ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP </span><br><span class="line">使用字段：mail, server</span><br></pre></td></tr></table></figure></p>
<p>指出允许的密码，密码指定为OpenSSL支持的格式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssl_prefer_server_ciphers</span><br><span class="line">语法：ssl_prefer_server_ciphers on | off </span><br><span class="line">默认值：off </span><br><span class="line">使用字段：mail, server</span><br></pre></td></tr></table></figure></p>
<p>依赖SSLv3和TLSv1协议的服务器密码将优先于客户端密码。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssl_protocols</span><br><span class="line">语法：ssl_protocols [SSLv2] [SSLv3] [TLSv1] </span><br><span class="line">默认值：SSLv2 SSLv3 TLSv1 </span><br><span class="line">使用字段：mail, server</span><br></pre></td></tr></table></figure></p>
<p>指定要使用的SSL协议。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssl_session_cache</span><br><span class="line">语法：ssl_session_cache [<span class="built_in">builtin</span>[:size [shared:name:size] </span><br><span class="line">默认值：<span class="built_in">builtin</span>:20480 </span><br><span class="line">使用字段：mail, server</span><br></pre></td></tr></table></figure></p>
<p>设置储存SSL会话的缓存类型和大小。<br>缓存类型为：</p>
<pre><code>builtin - 内建OpenSSL缓存，仅能用在一个工作进程中，缓存大小在会话总数中指定，注意：如果要使用这个类型可能会引起内存碎片问题，具体请查看下文中参考文档。
shared - 缓存在所有的工作进程中共享，缓存大小指定单位为字节，1MB缓存大概保存4000个会话，每个共享的缓存必须有自己的名称，相同名称的缓存可以使用在不同的虚拟主机中。
</code></pre><p>可以同时使用两个缓存类型，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl_session_cache  builtin:1000  shared:SSL:10m;</span><br></pre></td></tr></table></figure></p>
<p>然而仅当builtin没有影响共享缓存时会使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssl_session_timeout</span><br><span class="line">语法：ssl_session_timeout time </span><br><span class="line">默认值：5m </span><br><span class="line">使用字段：mail, server</span><br></pre></td></tr></table></figure></p>
<p>设置客户端能够反复使用储存在缓存中的会话参数时间。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">starttls</span><br><span class="line">语法：starttls on | off | only </span><br><span class="line">默认值：off </span><br><span class="line">使用字段：mail, server</span><br></pre></td></tr></table></figure></p>
<p>含义</p>
<pre><code>on - 允许为IMAP/SMTP使用STARTTLS和为POP3使用STLS。
off - 禁止命令STLS和STARTTLS。
only - 在客户端使用TLS启用STLS和STARTTLS。
</code></pre><h2 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h2><p>在更改配置文件之前首先备份配置文件nginx.conf<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /data/nginx/conf/nginx.conf /data/backup/nginx.conf20180403.bak</span><br></pre></td></tr></table></figure></p>
<h3 id="Nginx基本配置和参数说明"><a href="#Nginx基本配置和参数说明" class="headerlink" title="Nginx基本配置和参数说明"></a>Nginx基本配置和参数说明</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行用户</span></span><br><span class="line">user nobody;</span><br><span class="line"><span class="comment">#启动进程,通常设置成和cpu的数量相等</span></span><br><span class="line">worker_processes  1;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#全局错误日志及PID文件</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#工作模式及连接数上限</span></span><br><span class="line">events &#123;</span><br><span class="line">    <span class="comment">#epoll是多路复用IO(I/O Multiplexing)中的一种方式,</span></span><br><span class="line">    <span class="comment">#仅用于linux2.6以上内核,可以大大提高nginx的性能</span></span><br><span class="line">    use   epoll; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">#单个后台worker process进程的最大并发链接数    </span></span><br><span class="line">    worker_connections  1024;</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 并发总数是 worker_processes 和 worker_connections 的乘积</span></span><br><span class="line">    <span class="comment"># 即 max_clients = worker_processes * worker_connections</span></span><br><span class="line">    <span class="comment"># 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4  为什么</span></span><br><span class="line">    <span class="comment"># 为什么上面反向代理要除以4，应该说是一个经验值</span></span><br><span class="line">    <span class="comment"># 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000</span></span><br><span class="line">    <span class="comment"># worker_connections 值的设置跟物理内存大小有关</span></span><br><span class="line">    <span class="comment"># 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数</span></span><br><span class="line">    <span class="comment"># 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右</span></span><br><span class="line">    <span class="comment"># 我们来看看360M内存的VPS可以打开的文件句柄数是多少：</span></span><br><span class="line">    <span class="comment"># $ cat /proc/sys/fs/file-max</span></span><br><span class="line">    <span class="comment"># 输出 34336</span></span><br><span class="line">    <span class="comment"># 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内</span></span><br><span class="line">    <span class="comment"># 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置</span></span><br><span class="line">    <span class="comment"># 使得并发总数小于操作系统可以打开的最大文件数目</span></span><br><span class="line">    <span class="comment"># 其实质也就是根据主机的物理CPU和内存进行配置</span></span><br><span class="line">    <span class="comment"># 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。</span></span><br><span class="line">    <span class="comment"># ulimit -SHn 65535</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">http &#123;</span><br><span class="line">    <span class="comment">#设定mime类型,类型由mime.type文件定义</span></span><br><span class="line">    include    mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    <span class="comment">#设定日志格式</span></span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line"> </span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，</span></span><br><span class="line">    <span class="comment">#对于普通应用，必须设为 on,</span></span><br><span class="line">    <span class="comment">#如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，</span></span><br><span class="line">    <span class="comment">#以平衡磁盘与网络I/O处理速度，降低系统的uptime.</span></span><br><span class="line">    sendfile     on;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#连接超时时间</span></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    tcp_nodelay     on;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#开启gzip压缩</span></span><br><span class="line">    gzip  on;</span><br><span class="line">    gzip_disable <span class="string">"MSIE [1-6]."</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#设定请求缓冲</span></span><br><span class="line">    client_header_buffer_size    128k;</span><br><span class="line">    large_client_header_buffers  4 128k;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">#设定虚拟主机配置</span></span><br><span class="line">    server &#123;</span><br><span class="line">        <span class="comment">#侦听80端口</span></span><br><span class="line">        listen    80;</span><br><span class="line">        <span class="comment">#定义使用 www.nginx.cn访问</span></span><br><span class="line">        server_name  www.nginx.cn;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">#定义服务器的默认网站根目录位置</span></span><br><span class="line">        root html;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">#设定本虚拟主机的访问日志</span></span><br><span class="line">        access_log  logs/nginx.access.log  main;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">#默认请求</span></span><br><span class="line">        location / &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#定义首页索引文件的名称</span></span><br><span class="line">            index index.php index.html index.htm;   </span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 定义错误提示页面</span></span><br><span class="line">        error_page   500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">#静态文件，nginx自己处理</span></span><br><span class="line">        location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#过期30天，静态文件不怎么更新，过期可以设大一点，</span></span><br><span class="line">            <span class="comment">#如果频繁更新，则可以设置得小一点。</span></span><br><span class="line">            expires 30d;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">#PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.</span></span><br><span class="line">        location ~ .php$ &#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            include fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">#禁止访问 .htxxx 文件</span></span><br><span class="line">            location ~ /.ht &#123;</span><br><span class="line">            deny all;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment"># another virtual host using mix of IP-, name-, and port-based configuration</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       8000;</span></span><br><span class="line">    <span class="comment">#    listen       somename:8080;</span></span><br><span class="line">    <span class="comment">#    server_name  somename  alias  another.alias;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># HTTPS server</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       443 ssl;</span></span><br><span class="line">    <span class="comment">#    server_name  localhost;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_certificate      cert.pem;</span></span><br><span class="line">    <span class="comment">#    ssl_certificate_key  cert.key;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line">    <span class="comment">#    ssl_session_timeout  5m;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="line">    <span class="comment">#    ssl_prefer_server_ciphers  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="Nginx-location匹配规则"><a href="#Nginx-location匹配规则" class="headerlink" title="Nginx location匹配规则"></a>Nginx location匹配规则</h3><p>location匹配命令</p>
<pre><code>~      #波浪线表示执行一个正则匹配，区分大小写
~*    #表示执行一个正则匹配，不区分大小写
^~    #^~表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录
=      #进行普通字符精确匹配
@     #&quot;@&quot; 定义一个命名的 location，使用在内部定向时，例如 error_page, try_files
location 匹配的优先级(与location在配置文件中的顺序无关)
= 精确匹配会第一个被处理。如果发现精确匹配，nginx停止搜索其他匹配。
普通字符匹配，正则表达式规则和长的块规则将被优先和查询匹配，也就是说如果该项匹配还需去看有没有正则表达式匹配和更长的匹配。
^~ 则只匹配该规则，nginx停止搜索其他匹配，否则nginx会继续处理其他location指令。
最后匹配理带有&quot;~&quot;和&quot;~*&quot;的指令，如果找到相应的匹配，则nginx停止搜索其他匹配；当没有正则表达式或者没有正则表达式被匹配的情况下，那么匹配程度最高的逐字匹配指令会被使用。
</code></pre><p>例如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location  = / &#123;</span><br><span class="line">  <span class="comment"># 只匹配"/".</span></span><br><span class="line">  [ configuration A ] </span><br><span class="line">&#125;</span><br><span class="line">location  / &#123;</span><br><span class="line">  <span class="comment"># 匹配任何请求，因为所有请求都是以"/"开始</span></span><br><span class="line">  <span class="comment"># 但是更长字符匹配或者正则表达式匹配会优先匹配</span></span><br><span class="line">  [ configuration B ] </span><br><span class="line">&#125;</span><br><span class="line">location ^~ /images/ &#123;</span><br><span class="line">  <span class="comment"># 匹配任何以 /images/ 开始的请求，并停止匹配 其它location</span></span><br><span class="line">  [ configuration C ] </span><br><span class="line">&#125;</span><br><span class="line">location ~* .(gif|jpg|jpeg)$ &#123;</span><br><span class="line">  <span class="comment"># 匹配以 gif, jpg, or jpeg结尾的请求. </span></span><br><span class="line">  <span class="comment"># 但是所有 /images/ 目录的请求将由 [Configuration C]处理.   </span></span><br><span class="line">  [ configuration D ]</span><br></pre></td></tr></table></figure></p>
<h3 id="Nginx开启php支持"><a href="#Nginx开启php支持" class="headerlink" title="Nginx开启php支持"></a>Nginx开启php支持</h3><p>找到如下内容，删除注释字符,并将倒数第二行的 /scripts 替为 $document_root<br>修改前<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    root           html;</span></span><br><span class="line">        <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">        <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">        <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">        <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>修改后<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">            root           html;</span><br><span class="line">            fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">            fastcgi_index  index.php;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            include        fastcgi_params;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>重启后生效。</p>
<h3 id="Nginx配置反向代理"><a href="#Nginx配置反向代理" class="headerlink" title="Nginx配置反向代理"></a>Nginx配置反向代理</h3><p>nginx作为web服务器一个重要的功能就是反向代理。<br>nginx反向代理的指令不需要新增额外的模块，默认自带proxy_pass指令，只需要修改配置文件就可以实现反向代理。<br>配置前的准备工作，后端跑apache服务的ip和端口，也就是说可以通过<a href="http://ip:port能访问到你的网站。" target="_blank" rel="noopener">http://ip:port能访问到你的网站。</a><br>然后就可以新建一个vhost.conf,加入如下内容，记得修改ip和域名为你的ip和域名。<br>修改nginx.conf，添加 include test.conf 到http{}段, reload nginx就可以了。<br>test.conf文件如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Basic reverse proxy server ##</span></span><br><span class="line"><span class="comment">## Apache backend for www.test.com ##</span></span><br><span class="line">upstream apachephp  &#123;</span><br><span class="line">    server ip:8080; <span class="comment">#Apache</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">## Start www.test.com ##</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name  www.test.com;</span><br><span class="line"> </span><br><span class="line">    access_log  logs/test.access.log  main;</span><br><span class="line">    error_log  logs/test.error.log;</span><br><span class="line">    root   html;</span><br><span class="line">    index  index.html index.htm index.php;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">## send request back to apache ##</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass  http://apachephp;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">#Proxy Settings</span></span><br><span class="line">        proxy_redirect     off;</span><br><span class="line">        proxy_set_header   Host             <span class="variable">$host</span>;</span><br><span class="line">        proxy_set_header   X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line">        proxy_max_temp_file_size 0;</span><br><span class="line">        proxy_connect_timeout      90;</span><br><span class="line">        proxy_send_timeout         90;</span><br><span class="line">        proxy_read_timeout         90;</span><br><span class="line">        proxy_buffer_size          4k;</span><br><span class="line">        proxy_buffers              4 32k;</span><br><span class="line">        proxy_busy_buffers_size    64k;</span><br><span class="line">        proxy_temp_file_write_size 64k;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">## End www.test.com ##</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Nginx配置负载均衡"><a href="#Nginx配置负载均衡" class="headerlink" title="Nginx配置负载均衡"></a>Nginx配置负载均衡</h3><p>一个简单的负载均衡的示例，把<a href="http://www.test.com均衡到本机不同的端口，也可以改为均衡到不同的地址上。" target="_blank" rel="noopener">www.test.com均衡到本机不同的端口，也可以改为均衡到不同的地址上。</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line"> upstream myproject &#123;</span><br><span class="line"> server 127.0.0.1:8000 weight=3;</span><br><span class="line"> server 127.0.0.1:8001;</span><br><span class="line"> server 127.0.0.1:8002;</span><br><span class="line"> server 127.0.0.1:8003;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> server &#123;</span><br><span class="line"> listen 80;</span><br><span class="line"> server_name www.test.com;</span><br><span class="line"> location / &#123;</span><br><span class="line"> proxy_pass http://myproject;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Nginx配置图片服务器"><a href="#Nginx配置图片服务器" class="headerlink" title="Nginx配置图片服务器"></a>Nginx配置图片服务器</h3><p>首先建立存放图片的目录文件夹，在/data/nginx/html目录下建立images文件夹(也可以是其他路径)<br>Nginx默认使用端口是80，这里直接先把Nginx端口改为8088，在server字段中加入location字段<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(gif|jpg|jpeg|png)$ &#123;   <span class="comment">#关于图片格式的设定，可以增加其他图片格式</span></span><br><span class="line">            expires 24h;  </span><br><span class="line">            root /data/nginx/html/images/;<span class="comment">#指定图片存放路径  </span></span><br><span class="line">			autoindex on;<span class="comment">#打开预览功能</span></span><br><span class="line">            access_log /data/nginx/logs/images.log;<span class="comment">#图片日志路径 </span></span><br><span class="line">            <span class="comment">#以下为关于代理访问的配置，也可以关闭</span></span><br><span class="line">            proxy_store on;</span><br><span class="line">            proxy_store_access user:rw group:rw all:rw;  </span><br><span class="line">            proxy_temp_path         /data/nginx/html/images/;<span class="comment">#代理临时路径</span></span><br><span class="line">            proxy_redirect          off;  </span><br><span class="line">            proxy_set_header        Host 127.0.0.1;  </span><br><span class="line">            proxy_set_header        X-Real-IP <span class="variable">$remote_addr</span>;  </span><br><span class="line">            proxy_set_header        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;  </span><br><span class="line">            client_max_body_size    10m;  </span><br><span class="line">            client_body_buffer_size 1280k;  </span><br><span class="line">            proxy_connect_timeout   900;  </span><br><span class="line">            proxy_send_timeout      900;  </span><br><span class="line">            proxy_read_timeout      900;  </span><br><span class="line">            proxy_buffer_size       40k;  </span><br><span class="line">            proxy_buffers           40 320k;  </span><br><span class="line">            proxy_busy_buffers_size 640k;  </span><br><span class="line">            proxy_temp_file_write_size 640k;  </span><br><span class="line">            <span class="keyword">if</span> ( !-e <span class="variable">$request_filename</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                 proxy_pass  http://127.0.0.1:8088;<span class="comment">#代理访问地址，可以是其他地址</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一个简单的图片服务器就配置完成。</p>
<h3 id="Nginx配置动静分离"><a href="#Nginx配置动静分离" class="headerlink" title="Nginx配置动静分离"></a>Nginx配置动静分离</h3><p>Nginx是一种轻量级，高性能，多进程的Web服务器，非常适合作为静态资源的服务器使用，而动态的访问操作可以使用稳定的Apache、Tomcat及IIS等来实现，这里就以Nginx作为代理服务器的同时，也使用其作为静态资源的服务器，而动态的访问服务器就以Apache和Tomcat为例说明。<br>默认Nginx、Apache、Tomcat都安装在同台服务器，端口分别为80、88、8080。具体配置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认静态资源</span></span><br><span class="line">location / &#123;</span><br><span class="line">    root    /datda/nginx/html;</span><br><span class="line">	index  index.html index.htm   </span><br><span class="line">    allow all;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#动态资源加载</span></span><br><span class="line">location ~\.(php)?$ &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:88;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">#动态资源加载</span></span><br><span class="line">location ~\.(<span class="keyword">do</span>|jsp)?$ &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:8080;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>同时在Apache和Tomcat中关于动态资源目录的配置即可，可以是同目录，即/data/nginx/html。</p>
<h3 id="Nginx配置下载服务器"><a href="#Nginx配置下载服务器" class="headerlink" title="Nginx配置下载服务器"></a>Nginx配置下载服务器</h3><p>Nginx配置下载服务器即开启Nginx的索引功能，直接引导下载。可以直接对server字段进行配置，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       81; <span class="comment">#端口 </span></span><br><span class="line">        server_name  www.testa.com; <span class="comment">#服务名 </span></span><br><span class="line"> </span><br><span class="line">        charset utf-8;  <span class="comment">#避免中文乱码</span></span><br><span class="line">        root   /data/backup; <span class="comment">#显示的根索引目录，注意这里要改成你自己的，目录要存在 </span></span><br><span class="line"> </span><br><span class="line">        location / &#123;</span><br><span class="line">            autoindex on; <span class="comment">#开启索引功能</span></span><br><span class="line">            autoindex_exact_size off; <span class="comment">#关闭计算文件确切大小（单位bytes），只显示大概大小（单位kb、mb、gb） </span></span><br><span class="line">            autoindex_localtime on; <span class="comment">#显示本机时间而非 GMT 时间</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Nginx上的所有服务名不能重复，端口不能重复，此次使用81端口进行访问。</p>
<h3 id="Nginx配置邮件代理服务器"><a href="#Nginx配置邮件代理服务器" class="headerlink" title="Nginx配置邮件代理服务器"></a>Nginx配置邮件代理服务器</h3><p>一般情况下，客户端发起的邮件请求在经过Nginx这个邮件代理服务器后，从网络通信的角度来看，Nginx实现邮件代理功能时会把一个请求分为以下4个阶段：<br>接收并解析客户端初始请求的阶段。<br>向认证服务器验证请求合法性，并获取上游邮件服务器地址的阶段。<br>Nginx根据用户信息多次与上游服务器交互验证合法性的阶段。<br>Nginx在客户端与上游邮件服务器间纯粹透传TCP流的阶段。<br>由此可以了解到，这些Nginx邮件模块的目的非常明确，就是使用事件框架在大量并发连接下高效地处理这4个阶段的请求。<br>Nginx配置邮件代理服务器需要安装mail模块，安装参照Nginx升级操作。<br>关于Nginx配置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mail &#123;  </span><br><span class="line">    // 邮件认证服务器的访问URL  </span><br><span class="line">    auth_http IP:PORT/auth.php;  </span><br><span class="line">  </span><br><span class="line">    // 当透传上，下游间的TCP流时，每个请求所使用的内存缓冲区大小  </span><br><span class="line">    proxy_buffer 4k;  </span><br><span class="line">  </span><br><span class="line">    server &#123;  </span><br><span class="line">        /*对于POP3协议，通常都是监听110端口。POP3协议接收初始客户端请求的缓冲区固定为128字节，配置文件中无法设置*/  </span><br><span class="line">        listen 110;  </span><br><span class="line">        protocol pop3;  </span><br><span class="line">        proxy on;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    server &#123;  </span><br><span class="line">        // 对于IMAP，通常都是监听143端口  </span><br><span class="line">        listen 143;  </span><br><span class="line">        protocol imap;  </span><br><span class="line">        // 设置接收初始客户端请求的缓冲区大小  </span><br><span class="line">        imap_client_buffer 4k;  </span><br><span class="line">        proxy on;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    server &#123;  </span><br><span class="line">        // 对于SMTP，通常都是监听25端口  </span><br><span class="line">        listen 25;  </span><br><span class="line">        protocol smtp;  </span><br><span class="line">        proxy on;  </span><br><span class="line">        // 设置接收初始客户端请求的缓冲区大小  </span><br><span class="line">        smtp_client_buffer 4k;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Nginx配置PC端和手机端分离"><a href="#Nginx配置PC端和手机端分离" class="headerlink" title="Nginx配置PC端和手机端分离"></a>Nginx配置PC端和手机端分离</h3><p>一般情况下web网站的PC端页面和手机端页面是分开来开发的，那么就需要根据访问端的不同匹配到不同的页面，关于Nginx的配置示例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">server &#123; </span><br><span class="line">    listen       80;</span><br><span class="line">    <span class="comment">#server_name  www.testa.com; </span></span><br><span class="line"></span><br><span class="line">    client_max_body_size 100M;</span><br><span class="line">    client_body_buffer_size 100M;</span><br><span class="line">      </span><br><span class="line">    access_log  logs/access_80.log  main;</span><br><span class="line">    error_log   logs/error_80.log  error;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        add_header <span class="string">'Access-Control-Allow-Origin'</span> <span class="string">'*'</span>;</span><br><span class="line">        add_header <span class="string">'Access-Control-Allow_Credentials'</span> <span class="string">'true'</span>;</span><br><span class="line">        add_header <span class="string">'Access-Control-Allow-Headers'</span> <span class="string">'Authorization,Accept,Origin,DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range'</span>;</span><br><span class="line">        add_header <span class="string">'Access-Control-Allow-Methods'</span> <span class="string">'GET,POST,OPTIONS,PUT,DELETE,PATCH'</span>;</span><br><span class="line"></span><br><span class="line">        root  /data/work/front/FrontEndPage;</span><br><span class="line">        index index.html index.htm mobile.html;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$http_user_agent</span> ~* <span class="string">"(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino"</span>) &#123;</span><br><span class="line">            root    /data/work/front/FrontEndPage/mobile;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$http_user_agent</span> ~* <span class="string">"^(1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-)"</span>) &#123;</span><br><span class="line">            root    /data/work/front/FrontEndPage/mobile;</span><br><span class="line">        &#125;</span><br><span class="line">        try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">        error_page 405 =200 <span class="variable">$uri</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>手机端页面的首页为mobile.html，所以在自定义首页中加入mobile.html。<br>手机端页面目录mobile放在根目录下，实际生产中根据实际情况配置。</p>
<h2 id="Nginx优化"><a href="#Nginx优化" class="headerlink" title="Nginx优化"></a>Nginx优化</h2><h3 id="Nginx运行工作进程个数"><a href="#Nginx运行工作进程个数" class="headerlink" title="Nginx运行工作进程个数"></a>Nginx运行工作进程个数</h3><p>一般设置为CPU的核心数或者核心数的2倍<br>查看系统核心数，使用top命令后按1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top - 04:04:59 up 5 days, 22:57,  3 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks: 149 total,   1 running, 148 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu0  :  0.3 us,  0.3 sy,  0.0 ni, 98.7 id,  0.0 wa,  0.0 hi,  0.3 si,  0.3 st</span><br><span class="line">%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu2  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu3  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  7747784 total,  6489052 free,   138776 used,  1119956 buff/cache</span><br><span class="line">KiB Swap:  3145724 total,  3145724 free,        0 used.  7332688 avail Mem</span><br></pre></td></tr></table></figure></p>
<p>也可以通过命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo |grep processor |wc -l</span><br></pre></td></tr></table></figure></p>
<p>查看核心数，查看到CPU核心数为4，修改Nginx配置文件/data/nginx/conf/nginx.conf，修改后为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  4;</span><br></pre></td></tr></table></figure></p>
<p>重启nginx，查看nginx进程为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root     24041     1  0 Apr03 ?        00:00:00 nginx: master process nginx</span><br><span class="line">nobody   31044 24041  0 03:55 ?        00:00:00 nginx: worker process</span><br><span class="line">nobody   31045 24041  0 03:55 ?        00:00:00 nginx: worker process</span><br><span class="line">nobody   31046 24041  0 03:55 ?        00:00:00 nginx: worker process</span><br><span class="line">nobody   31047 24041  0 03:55 ?        00:00:00 nginx: worker process</span><br><span class="line">root     31695 14682  0 04:11 pts/0    00:00:00 grep --color=auto nginx</span><br></pre></td></tr></table></figure></p>
<p>可以看到Nginx的work process个数已经变为4个。</p>
<h3 id="Nginx运行CPU亲和力"><a href="#Nginx运行CPU亲和力" class="headerlink" title="Nginx运行CPU亲和力"></a>Nginx运行CPU亲和力</h3><p>比如4核配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  4;</span><br><span class="line">worker_cpu_affinity 0001 0010 0100 1000;</span><br></pre></td></tr></table></figure></p>
<p>比如8核配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker_processes 8;</span><br><span class="line">worker_cpu_affinity 00000001 00000010 00000100 0000100000010000 00100000 01000000 10000000;</span><br></pre></td></tr></table></figure></p>
<p>worker_processes最多开启8个，8个以上性能提升不会再提升了，而且稳定性变得更低，所以8个进程够用了。</p>
<h3 id="Nginx最多可以打开文件数"><a href="#Nginx最多可以打开文件数" class="headerlink" title="Nginx最多可以打开文件数"></a>Nginx最多可以打开文件数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_rlimit_nofile 65535;</span><br></pre></td></tr></table></figure>
<p>这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n的值保持一致。<br>注：</p>
<pre><code>文件资源限制的配置可以在/etc/security/limits.conf设置，针对root/user等各个用户或者*代表所有用户来设置。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*   soft  nofile   65535</span><br><span class="line">*   hard  nofile   65535</span><br></pre></td></tr></table></figure>
<p>用户重新登录生效（ulimit -n）</p>
<h3 id="Nginx事件处理模型"><a href="#Nginx事件处理模型" class="headerlink" title="Nginx事件处理模型"></a>Nginx事件处理模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">use epoll;</span><br><span class="line">worker_connections 65535;</span><br><span class="line">multi_accept on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nginx采用epoll事件模型，处理效率高<br>work_connections是单个worker进程允许客户端最大连接数，这个数值一般根据服务器性能和内存来制定，实际最大值就是worker进程数乘以work_connections<br>实际我们填入一个65535，足够了，这些都算并发值，一个网站的并发达到这么大的数量，也算一个大站了！<br>multi_accept 告诉nginx收到一个新连接通知后接受尽可能多的连接，默认是on，设置为on后，多个worker按串行方式来处理连接，也就是一个连接只有一个worker被唤醒，其他的处于休眠状态，设置为off后，多个worker按并行方式来处理连接，也就是一个连接会唤醒所有的worker，直到连接分配完毕，没有取得连接的继续休眠。当你的服务器连接数不多时，开启这个参数会让负载有一定的降低，但是当服务器的吞吐量很大时，为了效率，可以关闭这个参数。</p>
<h3 id="连接超时时间"><a href="#连接超时时间" class="headerlink" title="连接超时时间"></a>连接超时时间</h3><p>主要目的是保护服务器资源，CPU，内存，控制连接数，因为建立连接也是需要消耗资源的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">keepalive_timeout 60;</span><br><span class="line">tcp_nodelay on;</span><br><span class="line">client_header_buffer_size 4k;</span><br><span class="line">open_file_cache max=102400 inactive=20s;</span><br><span class="line">open_file_cache_valid 30s;</span><br><span class="line">open_file_cache_min_uses 1;</span><br><span class="line">client_header_timeout 15;</span><br><span class="line">client_body_timeout 15;</span><br><span class="line">reset_timedout_connection on;</span><br><span class="line">send_timeout 15;</span><br><span class="line">server_tokens off;</span><br><span class="line">client_max_body_size 10m;</span><br></pre></td></tr></table></figure></p>
<p>参数解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">keepalived_timeout客户端连接保持会话超时时间，超过这个时间，服务器断开这个链接</span><br><span class="line">tcp_nodelay；也是防止网络阻塞，不过要包涵在keepalived参数才有效</span><br><span class="line">client_header_buffer_size 4k;</span><br><span class="line">客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过 1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span><br><span class="line">open_file_cache max=102400 inactive=20s;</span><br><span class="line">这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件</span><br><span class="line">数一致，inactive 是指经过多长时间文件没被请求后删除缓存。</span><br><span class="line">open_file_cache_valid 30s;</span><br><span class="line">这个是指多长时间检查一次缓存的有效信息。</span><br><span class="line">open_file_cache_min_uses 1;</span><br><span class="line">open_file_cache指令中的inactive 参数时间内文件的最少使用次数，如果超过这个数字，文</span><br><span class="line">件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive 时间内一次没被使用，它将被移除。</span><br><span class="line">client_header_timeout设置请求头的超时时间。我们也可以把这个设置低些，如果超过这个时间没有发送任何数据，nginx将返回request time out的错误</span><br><span class="line">client_body_timeout设置请求体的超时时间。我们也可以把这个设置低些，超过这个时间没有发送任何数据，和上面一样的错误提示</span><br><span class="line">reset_timeout_connection 告诉nginx关闭不响应的客户端连接。这将会释放那个客户端所占有的内存空间。</span><br><span class="line">send_timeout响应客户端超时时间，这个超时时间仅限于两个活动之间的时间，如果超过这个时间，客户端没有任何活动，nginx关闭连接</span><br><span class="line">server_tokens  并不会让nginx执行的速度更快，但它可以关闭在错误页面中的nginx版本数字，这样对于安全性是有好处的。</span><br><span class="line">client_max_body_size上传文件大小限制</span><br></pre></td></tr></table></figure></p>
<h3 id="fastcgi调优"><a href="#fastcgi调优" class="headerlink" title="fastcgi调优"></a>fastcgi调优</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_connect_timeout    600;</span><br><span class="line">fastcgi_send_timeout 600;</span><br><span class="line">fastcgi_read_timeout 600;</span><br><span class="line">fastcgi_buffer_size 64k;</span><br><span class="line">fastcgi_buffers 4 64k;</span><br><span class="line">fastcgi_busy_buffers_size 128k;</span><br><span class="line">fastcgi_temp_file_write_size 128k;</span><br><span class="line">fastcgi_temp_path/usr/local/nginx1.10/nginx_tmp;</span><br><span class="line">fastcgi_intercept_errors on;</span><br><span class="line">fastcgi_cache_path/usr/local/nginx1.10/fastcgi_cache levels=1:2 keys_zone=cache_fastcgi:128minactive=1d max_size=10g;</span><br></pre></td></tr></table></figure>
<p>参数解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_connect_timeout 600; #指定连接到后端FastCGI的超时时间。</span><br><span class="line">fastcgi_send_timeout 600; #向FastCGI传送请求的超时时间。</span><br><span class="line">fastcgi_read_timeout 600; #指定接收FastCGI应答的超时时间。</span><br><span class="line">fastcgi_buffer_size 64k; #指定读取FastCGI应答第一部分需要用多大的缓冲区，默认的缓冲区大小为fastcgi_buffers指令中的每块大小，可以将这个值设置更小。</span><br><span class="line">fastcgi_buffers 4 64k; #指定本地需要用多少和多大的缓冲区来缓冲FastCGI的应答请求，如果一个php脚本所产生的页面大小为256KB，那么会分配4个64KB的缓冲区来缓存，如果页面大小大于256KB，那么大于256KB的部分会缓存到fastcgi_temp_path指定的路径中，但是这并不是好方法，因为内存中的数据处理速度要快于磁盘。一般这个值应该为站点中php脚本所产生的页面大小的中间值，如果站点大部分脚本所产生的页面大小为256KB，那么可以把这个值设置为“8 32K”、“4 64k”等。</span><br><span class="line">fastcgi_busy_buffers_size 128k; #建议设置为fastcgi_buffers的两倍，繁忙时候的buffer</span><br><span class="line">fastcgi_temp_file_write_size 128k;  #在写入fastcgi_temp_path时将用多大的数据块，默认值是fastcgi_buffers的两倍，该数值设置小时若负载上来时可能报502BadGateway</span><br><span class="line">fastcgi_temp_path #缓存临时目录</span><br><span class="line">fastcgi_intercept_errors on;#这个指令指定是否传递4xx和5xx错误信息到客户端，或者允许nginx使用error_page处理错误信息。</span><br><span class="line">注：静态文件不存在会返回404页面，但是php页面则返回空白页！！</span><br><span class="line">fastcgi_cache_path /usr/local/nginx1.10/fastcgi_cachelevels=1:2 keys_zone=cache_fastcgi:128minactive=1d max_size=10g;# fastcgi_cache缓存目录，可以设置目录层级，比如1:2会生成16*256个子目录，cache_fastcgi是这个缓存空间的名字，cache是用多少内存（这样热门的内容nginx直接放内存，提高访问速度），inactive表示默认失效时间，如果缓存数据在失效时间内没有被访问,将被删除，max_size表示最多用多少硬盘空间。</span><br><span class="line">fastcgi_cache cache_fastcgi;  #表示开启FastCGI缓存并为其指定一个名称。开启缓存非常有用，可以有效降低CPU的负载，并且防止502的错误放生。cache_fastcgi为proxy_cache_path指令创建的缓存区名称</span><br><span class="line">fastcgi_cache_valid 200 302 1h; #用来指定应答代码的缓存时间，实例中的值表示将200和302应答缓存一小时，要和fastcgi_cache配合使用</span><br><span class="line">fastcgi_cache_valid 301 1d;     #将301应答缓存一天</span><br><span class="line">fastcgi_cache_valid any 1m;     #将其他应答缓存为1分钟</span><br><span class="line">fastcgi_cache_min_uses 1;       #该指令用于设置经过多少次请求的相同URL将被缓存。</span><br><span class="line">fastcgi_cache_key http://$host$request_uri; #该指令用来设置web缓存的Key值,nginx根据Key值md5哈希存储.一般根据$host(域名)、$request_uri(请求的路径)等变量组合成proxy_cache_key 。</span><br><span class="line">fastcgi_pass #指定FastCGI服务器监听端口与地址，可以是本机或者其它</span><br><span class="line">总结：</span><br><span class="line">nginx的缓存功能有：proxy_cache / fastcgi_cache</span><br><span class="line">proxy_cache的作用是缓存后端服务器的内容，可能是任何内容，包括静态的和动态。</span><br><span class="line">fastcgi_cache的作用是缓存fastcgi生成的内容，很多情况是php生成的动态的内容。</span><br><span class="line">proxy_cache缓存减少了nginx与后端通信的次数，节省了传输时间和后端宽带。</span><br><span class="line">fastcgi_cache缓存减少了nginx与php的通信的次数，更减轻了php和数据库(mysql)的压力。</span><br><span class="line">CGI是为了保证web server传递过来的数据是标准格式的，方便CGI程序的编写者。Fastcgi是用来提高CGI程序性能的。php-fpm是fastcgi进程的管理器，用来管理fastcgi进程的</span><br></pre></td></tr></table></figure></p>
<h3 id="gzip调优"><a href="#gzip调优" class="headerlink" title="gzip调优"></a>gzip调优</h3><p>使用gzip压缩功能，可能为我们节约带宽，加快传输速度，有更好的体验，也为我们节约成本，所以说这是一个重点。<br>Nginx启用压缩功能需要你来ngx_http_gzip_module模块（apache使用的是mod_deflate）。<br>一般我们需要压缩的内容有：文本，js，html，css，对于图片，视频，flash什么的不压缩，同时也要注意，我们使用gzip的功能是需要消耗CPU的！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gzip on;</span><br><span class="line">gzip_min_length 2k;</span><br><span class="line">gzip_buffers    4 32k;</span><br><span class="line">gzip_http_version 1.1;</span><br><span class="line">gzip_comp_level 6;</span><br><span class="line">gzip_types text/plain text/css text/javascriptapplication/json application/javascript application/x-javascriptapplication/xml;</span><br><span class="line">gzip_vary on;</span><br><span class="line">gzip_proxied any;</span><br></pre></td></tr></table></figure></p>
<p>参数解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gzip on;    #开启压缩功能</span><br><span class="line">gzip_min_length 1k; #设置允许压缩的页面最小字节数，页面字节数从header头的Content-Length中获取，默认值是0，不管页面多大都进行压缩，建议设置成大于1K，如果小与1K可能会越压越大。</span><br><span class="line">gzip_buffers 4 32k; #压缩缓冲区大小，表示申请4个单位为32K的内存作为压缩结果流缓存，默认值是申请与原始数据大小相同的内存空间来存储gzip压缩结果。</span><br><span class="line">gzip_http_version 1.1; #压缩版本，用于设置识别HTTP协议版本，默认是1.1，目前大部分浏览器已经支持GZIP解压，使用默认即可</span><br><span class="line">gzip_comp_level 6; #压缩比例，用来指定GZIP压缩比，1压缩比最小，处理速度最快，9压缩比最大，传输速度快，但是处理慢，也比较消耗CPU资源。</span><br><span class="line">gzip_types text/css text/xml application/javascript; #用来指定压缩的类型，‘text/html’类型总是会被压缩。</span><br><span class="line">默认值: gzip_types text/html (默认不对js/css文件进行压缩)</span><br><span class="line"># 压缩类型，匹配MIME��型进行压缩</span><br><span class="line"># 不能用通配符 text/*</span><br><span class="line"># (无论是否指定)text/html默认已经压缩 </span><br><span class="line"># 设置哪压缩种文本文件可参考 conf/mime.types</span><br><span class="line">gzip_vary on;  #varyheader支持，改选项可以让前端的缓存服务器缓存经过GZIP压缩的页面，例如用Squid缓存经过nginx压缩的数据</span><br></pre></td></tr></table></figure></p>
<h3 id="expires缓存优化"><a href="#expires缓存优化" class="headerlink" title="expires缓存优化"></a>expires缓存优化</h3><p>缓存，主要针对于图片，css，js等元素更改机会比较少的情况下使用，特别是图片，占用带宽大，我们完全可以设置图片在浏览器本地缓存365d，css，js，html可以缓存个10来天，这样用户第一次打开加载慢一点，第二次，就非常快了！缓存的时候，我们需要将需要缓存的拓展名列出来， Expires缓存配置在server字段里面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">location ~* \.(ico|jpe?g|gif|png|bmp|swf|flv)$ &#123;</span><br><span class="line">  expires 30d;</span><br><span class="line">  <span class="comment">#log_not_found off;</span></span><br><span class="line">  access_log off;</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.(js|css)$ &#123;</span><br><span class="line">  expires 7d;</span><br><span class="line">  log_not_found off;</span><br><span class="line">  access_log off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：log_not_found off;是否在error_log中记录不存在的错误。默认是。<br>总结：<br>expire功能优点</p>
<pre><code>expires可以降低网站购买的带宽，节约成本
同时提升用户访问体验
减轻服务的压力，节约服务器成本，是web服务非常重要的功能。 
</code></pre><p>expire功能缺点</p>
<pre><code>被缓存的页面或数据更新了，用户看到的可能还是旧的内容，反而影响用户体验。解决办法：第一个缩短缓存时间，例如：1天，但不彻底，除非更新频率大于1天；第二个对缓存的对象改名。
网站不希望被缓存的内容 1）网站流量统计工具2）更新频繁的文件
</code></pre><h3 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h3><p>防止别人直接从你网站引用图片等链接，消耗了你的资源和网络流量，那么我们的解决办法由几种： 1：水印，品牌宣传，你的带宽，服务器足够<br>2：防火墙，直接控制，前提是你知道IP来源<br>3：防盗链策略下面的方法是直接给予404的错误提示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location ~*^.+\.(jpg|gif|png|swf|flv|wma|wmv|asf|mp3|mmf|zip|rar)$ &#123;</span><br><span class="line">    valid_referers noneblocked  www.benet.com benet.com;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$invalid_referer</span>) &#123;</span><br><span class="line">      <span class="comment">#return 302  http://127.0.0.1/img/nolink.jpg;</span></span><br><span class="line">      <span class="built_in">return</span> 404;</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    access_log off;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>参数可以使如下形式：<br>none 意思是不存在的Referer头(表示空的，也就是直接访问，比如直接在浏览器打开一个图片)<br>blocked 意为根据防火墙伪装Referer头，如：“Referer:XXXXXXX”。<br>server_names 为一个或多个服务器的列表。</p>
<h3 id="系统内核参数优化"><a href="#系统内核参数优化" class="headerlink" title="系统内核参数优化"></a>系统内核参数优化</h3><p>fs.file-max = 999999：这个参数表示进程（比如一个worker进程）可以同时打开的最大句柄数，这个参数直线限制最大并发连接数，需根据实际情况配置。<br>net.ipv4.tcp_max_tw_buckets = 6000 #这个参数表示操作系统允许TIME_WAIT套接字数量的最大值，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。该参数默认为180000，过多的TIME_WAIT套接字会使Web服务器变慢。<br>注：主动关闭连接的服务端会产生TIME_WAIT状态的连接<br>net.ipv4.ip_local_port_range = 1024 65000 #允许系统打开的端口范围。<br>net.ipv4.tcp_tw_recycle = 1#启用timewait快速回收。<br>net.ipv4.tcp_tw_reuse = 1#开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接。这对于服务器来说很有意义，因为服务器上总会有大量TIME-WAIT状态的连接。<br>net.ipv4.tcp_keepalive_time = 30：这个参数表示当keepalive启用时，TCP发送keepalive消息的频度。默认是2小时，若将其设置的小一些，可以更快地清理无效的连接。<br>net.ipv4.tcp_syncookies = 1#开启SYN Cookies，当出现SYN等待队列溢出时，启用cookies来处理。<br>net.core.somaxconn = 40960 #web 应用中 listen 函数的 backlog 默认会给我们内核参数的 net.core.somaxconn 限制到128，而nginx定义的NGX_LISTEN_BACKLOG 默认为511，所以有必要调整这个值。<br>注：对于一个TCP连接，Server与Client需要通过三次握手来建立网络连接.当三次握手成功后,我们可以看到端口的状态由LISTEN转变为ESTABLISHED,接着这条链路上就可以开始传送数据了.每一个处于监听(Listen)状态的端口,都有自己的监听队列.监听队列的长度与如somaxconn参数和使用该端口的程序中listen()函数有关<br>somaxconn参数:定义了系统中每一个端口最大的监听队列的长度,这是个全局的参数,默认值为128，对于一个经常处理新连接的高负载 web服务环境来说，默认的 128 太小了。大多数环境这个值建议增加到 1024 或者更多。大的侦听队列对防止拒绝服务 DoS 攻击也会有所帮助。<br>net.core.netdev_max_backlog = 262144 #每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。<br>net.ipv4.tcp_max_syn_backlog = 262144 #这个参数标示TCP三次握手建立阶段接受SYN请求队列的最大长度，默认为1024，将其设置得大一些可以使出现Nginx繁忙来不及accept新连接的情况时，Linux不至于丢失客户端发起的连接请求。<br>net.ipv4.tcp_rmem = 10240 87380 12582912#这个参数定义了TCP接受缓存（用于TCP接受滑动窗口）的最小值、默认值、最大值。<br>net.ipv4.tcp_wmem = 10240 87380 12582912：这个参数定义了TCP发送缓存（用于TCP发送滑动窗口）的最小值、默认值、最大值。<br>net.core.rmem_default = 6291456：这个参数表示内核套接字接受缓存区默认的大小。<br>net.core.wmem_default = 6291456：这个参数表示内核套接字发送缓存区默认的大小。<br>net.core.rmem_max = 12582912：这个参数表示内核套接字接受缓存区的最大大小。<br>net.core.wmem_max = 12582912：这个参数表示内核套接字发送缓存区的最大大小。<br>net.ipv4.tcp_syncookies = 1：该参数与性能无关，用于解决TCP的SYN攻击。</p>
<p>完整的内核优化设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">fs.file-max = 999999</span><br><span class="line">net.ipv4.ip_forward = 0</span><br><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">kernel.sysrq = 0</span><br><span class="line">kernel.core_uses_pid = 1</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line">kernel.msgmax = 65536</span><br><span class="line">kernel.shmmax = 68719476736</span><br><span class="line">kernel.shmall = 4294967296</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 6000</span><br><span class="line">net.ipv4.tcp_sack = 1</span><br><span class="line">net.ipv4.tcp_window_scaling = 1</span><br><span class="line">net.ipv4.tcp_rmem = 10240 87380 12582912</span><br><span class="line">net.ipv4.tcp_wmem = 10240 87380 12582912</span><br><span class="line">net.core.wmem_default = 8388608</span><br><span class="line">net.core.rmem_default = 8388608</span><br><span class="line">net.core.rmem_max = 16777216</span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line">net.core.netdev_max_backlog = 262144</span><br><span class="line">net.core.somaxconn = 40960</span><br><span class="line">net.ipv4.tcp_max_orphans = 3276800</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 262144</span><br><span class="line">net.ipv4.tcp_timestamps = 0</span><br><span class="line">net.ipv4.tcp_synack_retries = 1</span><br><span class="line">net.ipv4.tcp_syn_retries = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_mem = 94500000 915000000 927000000</span><br><span class="line">net.ipv4.tcp_fin_timeout = 1</span><br><span class="line">net.ipv4.tcp_keepalive_time = 30</span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65000</span><br></pre></td></tr></table></figure></p>
<p>执行sysctl -p使内核修改生效。</p>
<h3 id="系统连接数的优化"><a href="#系统连接数的优化" class="headerlink" title="系统连接数的优化"></a>系统连接数的优化</h3><p>linux 默认值 open files为1024</p>
<p>#ulimit -n<br>1024<br>说明server只允许同时打开1024个文件<br>使用ulimit -a 可以查看当前系统的所有限制值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 31175</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 31175</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure></p>
<p>使用ulimit -n 可以查看当前的最大打开文件数。<br>新装的linux 默认只有1024 ，当作负载较大的服务器时，很容易遇到error: too many open files。因此，需要将其改大<br>在/etc/security/limits.conf最后增加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*               soft    nofile          65535</span><br><span class="line">*               hard    nofile          65535</span><br><span class="line">*               soft    noproc          65535</span><br><span class="line">*               hard    noproc          65535</span><br></pre></td></tr></table></figure></p>

      
    </div>

    

    
    
    

    <div>
      
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/posts/8dddf073.html">Nginx文档</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 Francis 的个人博客">Francis</a></p>
  <p><span>原始链接:</span><a href="/posts/8dddf073.html" title="Nginx文档">http://www.cnops.com/posts/8dddf073.html</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://www.cnops.com/posts/8dddf073.html" aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
      $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({   
          title: "",   
          text: '复制成功',
          icon: "success", 
          showConfirmButton: true
          });
        });
    });  
</script>

      
    </div>

    

    
       
    
    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="Francis 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="Francis 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Nginx/" rel="tag"><i class="fa fa-tag"></i> Nginx</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/8d4248f1.html" rel="next" title="xargs用法">
                <i class="fa fa-chevron-left"></i> xargs用法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/aec0db0.html" rel="prev" title="搭建内网NTP时间服务器">
                搭建内网NTP时间服务器 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Francis</p>
              <p class="site-description motion-element" itemprop="description">云在青天水在瓶</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">54</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">32</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">101</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/francisxys" title="GitHub &rarr; https://github.com/francisxys" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:824014778@qq.com" title="E-Mail &rarr; mailto:824014778@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/Teotihuacanxys" title="Weibo &rarr; https://weibo.com/Teotihuacanxys" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.tiejiang.org" title="http://www.tiejiang.org" rel="noopener" target="_blank">铁匠运维网</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.ityouknow.com/" title="http://www.ityouknow.com/" rel="noopener" target="_blank">纯洁的微笑</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx作用"><span class="nav-text">Nginx作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx版本选择"><span class="nav-text">Nginx版本选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nginx安装、升级、卸载"><span class="nav-text">Nginx安装、升级、卸载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#windows-server环境安装"><span class="nav-text">windows server环境安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#下载解压后"><span class="nav-text">下载解压后</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修改配置文件"><span class="nav-text">修改配置文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#启动Nginx"><span class="nav-text">启动Nginx</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux-server安装Nginx"><span class="nav-text">linux server安装Nginx</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#yum安装方式"><span class="nav-text">yum安装方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编译安装方式"><span class="nav-text">编译安装方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx升级、添加模块"><span class="nav-text">Nginx升级、添加模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx卸载"><span class="nav-text">Nginx卸载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nginx常用命令"><span class="nav-text">Nginx常用命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nginx模块介绍"><span class="nav-text">Nginx模块介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#核心模块"><span class="nav-text">核心模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主模块"><span class="nav-text">主模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事件模块"><span class="nav-text">事件模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标准HTTP模块"><span class="nav-text">标准HTTP模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP核心模块"><span class="nav-text">HTTP核心模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP负载均衡模块"><span class="nav-text">HTTP负载均衡模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP访问控制模块"><span class="nav-text">HTTP访问控制模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP基本认证模块"><span class="nav-text">HTTP基本认证模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP目录清单生成模块"><span class="nav-text">HTTP目录清单生成模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#浏览器相关模块"><span class="nav-text">浏览器相关模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符集设置模块"><span class="nav-text">字符集设置模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Empty-GIF模块"><span class="nav-text">Empty GIF模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FastCGI模块"><span class="nav-text">FastCGI模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Geo模块"><span class="nav-text">Geo模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Gzip模块"><span class="nav-text">Gzip模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP头处理模块"><span class="nav-text">HTTP头处理模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#默认主页设置模块"><span class="nav-text">默认主页设置模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-Referer模块"><span class="nav-text">HTTP Referer模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-Limit-Zone模块"><span class="nav-text">HTTP Limit Zone模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-Limit-Requests模块"><span class="nav-text">HTTP Limit Requests模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#日志模块"><span class="nav-text">日志模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map模块"><span class="nav-text">Map模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Memcached模块"><span class="nav-text">Memcached模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP代理模块"><span class="nav-text">HTTP代理模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#URL重写模块"><span class="nav-text">URL重写模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SSI模块"><span class="nav-text">SSI模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#User-ID模块"><span class="nav-text">User ID模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#uWSGI模块"><span class="nav-text">uWSGI模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SplitClients模块"><span class="nav-text">SplitClients模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可选HTTP模块"><span class="nav-text">可选HTTP模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-Addition模块"><span class="nav-text">HTTP Addition模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#邮件模块"><span class="nav-text">邮件模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#邮件核心模块"><span class="nav-text">邮件核心模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#邮件认证模块"><span class="nav-text">邮件认证模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#邮件代理模块"><span class="nav-text">邮件代理模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#邮件SSL认证模块"><span class="nav-text">邮件SSL认证模块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nginx配置"><span class="nav-text">Nginx配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx基本配置和参数说明"><span class="nav-text">Nginx基本配置和参数说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx-location匹配规则"><span class="nav-text">Nginx location匹配规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx开启php支持"><span class="nav-text">Nginx开启php支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx配置反向代理"><span class="nav-text">Nginx配置反向代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx配置负载均衡"><span class="nav-text">Nginx配置负载均衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx配置图片服务器"><span class="nav-text">Nginx配置图片服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx配置动静分离"><span class="nav-text">Nginx配置动静分离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx配置下载服务器"><span class="nav-text">Nginx配置下载服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx配置邮件代理服务器"><span class="nav-text">Nginx配置邮件代理服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx配置PC端和手机端分离"><span class="nav-text">Nginx配置PC端和手机端分离</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nginx优化"><span class="nav-text">Nginx优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx运行工作进程个数"><span class="nav-text">Nginx运行工作进程个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx运行CPU亲和力"><span class="nav-text">Nginx运行CPU亲和力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx最多可以打开文件数"><span class="nav-text">Nginx最多可以打开文件数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx事件处理模型"><span class="nav-text">Nginx事件处理模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接超时时间"><span class="nav-text">连接超时时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fastcgi调优"><span class="nav-text">fastcgi调优</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gzip调优"><span class="nav-text">gzip调优</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#expires缓存优化"><span class="nav-text">expires缓存优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#防盗链"><span class="nav-text">防盗链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统内核参数优化"><span class="nav-text">系统内核参数优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统连接数的优化"><span class="nav-text">系统连接数的优化</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Francis</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">486k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">7:21</span>
  
</div>

<!--

  <div class="powered-by"><a href="https://www.cnops.top" class="theme-link" rel="noopener" target="_blank">Francis</a> 个人专属</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">博客</div>

-->

<div class="BbeiAn-info">
    <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41042202000126" style="color:#000000;text-decoration:none;padding-left:30px;background:url(https://francisblogstatic.oss-cn-shanghai.aliyuncs.com/images/batb.png) no-repeat left center" rel="nofollow">豫公网安备 41042202000126号</a>    <!--这里将图标作为了背景，以使得能和后面的文字在同一行-->
</div>



        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.6.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.6.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
